<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「区块链」：Solidity-basic - fred&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fred&#039;s blog"><meta name="msapplication-TileImage" content="/img/heart.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fred&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Solidity的官方教程笔记：basic。"><meta property="og:type" content="blog"><meta property="og:title" content="「区块链」：Solidity-basic"><meta property="og:url" content="https://f7ed.com/2020/11/03/solidity-basic/"><meta property="og:site_name" content="fred&#039;s blog"><meta property="og:description" content="Solidity的官方教程笔记：basic。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://f7ed.com/gallery/thumbnails/ethereum-VM-solidity.png"><meta property="article:published_time" content="2020-11-02T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-22T02:30:41.268Z"><meta property="article:author" content="f7ed"><meta property="article:tag" content="blockchain"><meta property="article:tag" content="solidity"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/thumbnails/ethereum-VM-solidity.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://f7ed.com/2020/11/03/solidity-basic/"},"headline":"「区块链」：Solidity-basic","image":["https://f7ed.com/gallery/thumbnails/ethereum-VM-solidity.png"],"datePublished":"2020-11-02T16:00:00.000Z","dateModified":"2021-05-22T02:30:41.268Z","author":{"@type":"Person","name":"f7ed"},"publisher":{"@type":"Organization","name":"fred's blog","logo":{"@type":"ImageObject","url":"https://f7ed.com/img/f1ed_logo.png"}},"description":"Solidity的官方教程笔记：basic。"}</script><link rel="canonical" href="https://f7ed.com/2020/11/03/solidity-basic/"><link rel="icon" href="/img/heart.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-M5KG3CQTSF" async></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-M5KG3CQTSF');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="fred's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/liu">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-bars"></i>「区块链」：Solidity-basic</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2020-11-02T16:00:00.000Z" title="2020-11-02T16:00:00.000Z">2020-11-03</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-05-22T02:30:41.268Z" title="2021-05-22T02:30:41.268Z">2021-05-22</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span><span class="level-item"><i class="far fa-clock"></i> 38 minutes read (About 5724 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>Solidity的<a target="_blank" rel="noopener" href="https://cryptozombies.io/zh/course">官方教程</a>笔记：basic。 </p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="more"></span>

<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h2><p>从最基本的开始入手:</p>
<p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p>
<p>一份名为 <code>HelloWorld</code> 的空合约如下:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">contract HelloWorld </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable"></span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="版本指令"><a href="#版本指令" class="headerlink" title="版本指令"></a>版本指令</h3><p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p>
<p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p>
<p><strong>要有分号！</strong> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line">contract <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h2><p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p>
<h3 id="无符号整数-uint"><a href="#无符号整数-uint" class="headerlink" title="无符号整数: uint"></a>无符号整数: <code>uint</code></h3><p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p>
<p><em>注: Solidity中，</em> <code>uint</code> <em>实际上是</em> <code>uint256</code><em>代名词， 一个256位的无符号整数。你也可以定义位数少的uints —</em> <code>uint8</code><em>，</em> <code>uint16</code><em>，</em> <code>uint32</code><em>， 等…… 但一般来讲你愿意使用简单的</em> <code>uint</code><em>， 除非在某些特殊情况下，这我们后面会讲。</em></p>
<h2 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h2><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p>
<ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code>,</li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li>
</ul>
<p>Solidity 还支持 <strong><em>乘方操作\</em></strong> (如：x 的 y次方） </p>
<p>如： 5 ** 2 = 25</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></table></figure>

<h2 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="title class_">Person</span> &#123;</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h2><p>如果你想建立一个集合，可以用 <strong><em>数组</em></strong>这样的数据类型. Solidity 支持两种数组: <strong><em>静态</em></strong> 数组和<strong><em>动态</em></strong> 数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定长度为2的静态数组:</span></span><br><span class="line">uint[<span class="number">2</span>] fixedArray;</span><br><span class="line"><span class="comment">// 固定长度为5的string类型的静态数组:</span></span><br><span class="line">string[<span class="number">5</span>] stringArray;</span><br><span class="line"><span class="comment">// 动态数组，长度不固定，可以动态添加元素:</span></span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></table></figure>

<p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p>
<h3 id="公共数组"><a href="#公共数组" class="headerlink" title="公共数组"></a>公共数组</h3><p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>[] public people;</span><br></pre></td></tr></table></figure>

<p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p>
<h2 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h2><p>在 Solidity 中函数定义的句法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eatHamburgers</span>(<span class="params">string _name, uint _amount</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：习惯上函数里的变量都是以(*<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。(整个教程都会沿用这个习惯。)</p>
<h2 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h2><p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的Person:</span></span><br><span class="line"><span class="title class_">Person</span> satoshi = <span class="title class_">Person</span>(<span class="number">172</span>, <span class="string">&quot;Satoshi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新创建的satoshi添加进people数组:</span></span><br><span class="line">people.<span class="title function_">push</span>(satoshi);</span><br></pre></td></tr></table></figure>

<p>你也可以两步并一步，用一行代码更简洁:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.<span class="title function_">push</span>(<span class="title class_">Person</span>(<span class="number">16</span>, <span class="string">&quot;Vitalik&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p>
</blockquote>
<h2 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h2><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p>
<p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p>
<p>如何定义一个私有的函数呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_addToArray</span>(<span class="params">uint _number</span>) private &#123;</span><br><span class="line">  numbers.<span class="title function_">push</span>(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p>
<p>可以看到，在函数名字后面使用关键字 <code>private</code> 即可。和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</p>
<h2 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h2><p>本章中我们将学习函数的返回值和修饰符。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>要想函数返回一个数值，按如下定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = <span class="string">&quot;What&#x27;s up dog&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) public <span class="title function_">returns</span> (string) &#123;</span><br><span class="line">  <span class="keyword">return</span> greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p>
<h3 id="函数的修饰符"><a href="#函数的修饰符" class="headerlink" title="函数的修饰符"></a>函数的修饰符</h3><p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p>
<p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (string) &#123;</span><br></pre></td></tr></table></figure>

<p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_multiply</span>(<span class="params">uint a, uint b</span>) private pure <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 <strong>pure</strong>.</p>
<blockquote>
<p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p>
</blockquote>
<h2 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h2><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p>
<p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p>
<p>例子:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span></span><br><span class="line"><span class="built_in">keccak256</span>(&quot;aaaab&quot;);</span><br><span class="line"><span class="comment">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span></span><br><span class="line"><span class="built_in">keccak256</span>(&quot;aaaac&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注: 在区块链中<strong><em>安全地</em></strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。*</p>
</blockquote>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>有时你需要变换数据类型。例如:</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">uint</span> b = <span class="number">6</span>;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 <span class="type">uint</span>, 而不是 <span class="type">uint8</span>:</span><br><span class="line"><span class="type">uint8</span> c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 <span class="type">uint8</span>:</span><br><span class="line"><span class="type">uint8</span> c = a * <span class="type">uint8</span>(b);</span><br></pre></td></tr></table></figure>

<p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p>
<h2 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h2><p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里建立事件</span></span><br><span class="line">event <span class="title class_">IntegersAdded</span>(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint _x, uint _y</span>) public &#123;</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  <span class="comment">//触发事件，通知app</span></span><br><span class="line">  <span class="title class_">IntegersAdded</span>(_x, _y, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">YourContract</span>.<span class="title class_">IntegersAdded</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123; </span><br><span class="line">  <span class="comment">// 干些事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。</p>
<h2 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h2><p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p>
<p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">&quot;#ourButton&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">&quot;#nameInput&quot;</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">&quot;0&quot;</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = &#123;</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">&quot;A Level 1 CryptoZombie&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p>
<hr>
<h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h2><p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p>
<h3 id="Addresses-（地址）"><a href="#Addresses-（地址）" class="headerlink" title="Addresses （地址）"></a>Addresses （地址）</h3><p>以太坊区块链由 <strong>account ** (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 **<em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p>
<p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span></span><br></pre></td></tr></table></figure>

<p>现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p>
<h3 id="Mapping（映射）"><a href="#Mapping（映射）" class="headerlink" title="Mapping（映射）"></a>Mapping（映射）</h3><p>在第1课中，我们看到了 <strong>结构体 ** 和 **数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p>
<p>映射是这样定义的：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span></span><br><span class="line">mapping (address =&gt; <span class="keyword">uint</span>) <span class="keyword">public</span> accountBalance;</span><br><span class="line"><span class="comment">//或者可以用来通过userId 存储/查找的用户名</span></span><br><span class="line">mapping (<span class="keyword">uint</span> =&gt; <span class="keyword">string</span>) userIdToName;</span><br></pre></td></tr></table></figure>

<p>映射本质上是存储和查找数据所用的键-值对。</p>
<h2 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h2><h3 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h3><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p>
<blockquote>
<p><em>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以</em> <code>msg.sender</code><em>总是存在的。</em></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mapping</span> (<span class="function"><span class="params">address</span> =&gt;</span> uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setMyNumber</span>(<span class="params">uint _myNumber</span>) public &#123;</span><br><span class="line">  <span class="comment">// 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span></span><br><span class="line">  favoriteNumber[msg.<span class="property">sender</span>] = _myNumber;</span><br><span class="line">  <span class="comment">// 存储数据至映射的方法和将数据存储在数组相似</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">whatIsMyNumber</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">  <span class="comment">// 拿到存储在调用者地址名下的值</span></span><br><span class="line">  <span class="comment">// 若调用者还没调用 setMyNumber， 则值为 `0`</span></span><br><span class="line">  <span class="keyword">return</span> favoriteNumber[msg.<span class="property">sender</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p>
<p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p>
<p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = <span class="number">0</span>;</span><br><span class="line">number++;</span><br><span class="line"><span class="comment">// `number` 现在是 `1`了</span></span><br></pre></td></tr></table></figure>

<h2 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h2><p> <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHiToVitalik</span>(<span class="params">string _name</span>) public <span class="title function_">returns</span> (string) &#123;</span><br><span class="line">  <span class="comment">// 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序</span></span><br><span class="line">  <span class="comment">// (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span></span><br><span class="line">  <span class="comment">// 两字符串的 keccak256 哈希值来进行判断)</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="title function_">keccak256</span>(_name) == <span class="title function_">keccak256</span>(<span class="string">&quot;Vitalik&quot;</span>));</span><br><span class="line">  <span class="comment">// 如果返回 true, 运行如下语句</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p>
<p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p>
<h2 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h2><p> 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p>
<p>有个让 Solidity 的代码易于管理的功能，就是合约 <strong>inheritance</strong> (继承)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">Doge</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">catchphrase</span>(<span class="params"></span>) public <span class="title function_">returns</span> (string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;So Wow CryptoDoge&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">BabyDoge</span> is <span class="title class_">Doge</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">anotherCatchphrase</span>(<span class="params"></span>) public <span class="title function_">returns</span> (string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Such Moon BabyDoge&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 <strong>inherits</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p>
<p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p>
<h2 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h2><p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./someothercontract.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract newContract is <span class="title class_">SomeOtherContract</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p>
<h2 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h2><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p>
<p><strong>Storage</strong> 变量是指永久存储在区块链中的变量。 <strong>Memory</strong> 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p>
<p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p>
<p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">SandwichFactory</span> &#123;</span><br><span class="line">  struct <span class="title class_">Sandwich</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Sandwich</span>[] sandwiches;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">eatSandwich</span>(<span class="params">uint _index</span>) public &#123;</span><br><span class="line">    <span class="comment">// Sandwich mySandwich = sandwiches[_index];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ^ 看上去很直接，不过 Solidity 将会给出警告</span></span><br><span class="line">    <span class="comment">// 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以你应该明确定义 `storage`:把他当指针</span></span><br><span class="line">    <span class="title class_">Sandwich</span> storage mySandwich = sandwiches[_index];</span><br><span class="line">    <span class="comment">// ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span></span><br><span class="line">    <span class="comment">// 在存储里，另外...</span></span><br><span class="line">    mySandwich.<span class="property">status</span> = <span class="string">&quot;Eaten!&quot;</span>;</span><br><span class="line">    <span class="comment">// ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你只想要一个副本，可以使用`memory`:在内存的临时副本</span></span><br><span class="line">    <span class="title class_">Sandwich</span> memory anotherSandwich = sandwiches[_index + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span></span><br><span class="line">    <span class="comment">// 另外</span></span><br><span class="line">    anotherSandwich.<span class="property">status</span> = <span class="string">&quot;Eaten!&quot;</span>;</span><br><span class="line">    <span class="comment">// ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span></span><br><span class="line">    <span class="comment">// 不过你可以这样做:</span></span><br><span class="line">    sandwiches[_index + <span class="number">1</span>] = anotherSandwich;</span><br><span class="line">    <span class="comment">// ...如果你想把副本的改动保存回区块链存储</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你不得不使用到这些关键字的时候，Solidity 编译器会发警示提醒你的。</p>
<h2 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h2><p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p>
<h3 id="internal-和-external"><a href="#internal-和-external" class="headerlink" title="internal 和 external"></a>internal 和 external</h3><p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p>
<p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。而private只允许合约内部函数访问。</p>
<p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用，它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。而public允许合约内和合约外的函数调用。</p>
<p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">Sandwich</span> &#123;</span><br><span class="line">  uint private sandwichesEaten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">eat</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="variable constant_">BLT</span> is <span class="title class_">Sandwich</span> &#123;</span><br><span class="line">  uint private baconSandwichesEaten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">eatWithBacon</span>(<span class="params"></span>) public <span class="title function_">returns</span> (string) &#123;</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    <span class="comment">// 因为eat() 是internal 的，所以我们能在这里调用</span></span><br><span class="line">    <span class="title function_">eat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="与其他合约的交互"><a href="#与其他合约的交互" class="headerlink" title="与其他合约的交互"></a>与其他合约的交互</h3><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p>
<p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">LuckyNumber</span> &#123;</span><br><span class="line">  <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) numbers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setNum</span>(<span class="params">uint _num</span>) public &#123;</span><br><span class="line">    numbers[msg.<span class="property">sender</span>] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params">address _myAddress</span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p>
<p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p>
<p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">NumberInterface</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params">address _myAddress</span>) public view <span class="title function_">returns</span> (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<p>首先，我们只声明了要与之交互的函数 （在本例中为 <code>getNum</code> ），在其中我们没有使用到任何其他的函数或状态变量。</p>
<p>其次，我们并没有使用大括号（<code>&#123;</code> 和 <code>&#125;</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>
<p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p>
<p>该函数如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getKitty</span>(<span class="params">uint256 _id</span>) external view <span class="title function_">returns</span> (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="title class_">Kitty</span> storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this variable is 0 then it&#x27;s not gestating</span></span><br><span class="line">    isGestating = (kit.<span class="property">siringWithId</span> != <span class="number">0</span>);</span><br><span class="line">    isReady = (kit.<span class="property">cooldownEndBlock</span> &lt;= block.<span class="property">number</span>);</span><br><span class="line">    cooldownIndex = <span class="title function_">uint256</span>(kit.<span class="property">cooldownIndex</span>);</span><br><span class="line">    nextActionAt = <span class="title function_">uint256</span>(kit.<span class="property">cooldownEndBlock</span>);</span><br><span class="line">    siringWithId = <span class="title function_">uint256</span>(kit.<span class="property">siringWithId</span>);</span><br><span class="line">    birthTime = <span class="title function_">uint256</span>(kit.<span class="property">birthTime</span>);</span><br><span class="line">    matronId = <span class="title function_">uint256</span>(kit.<span class="property">matronId</span>);</span><br><span class="line">    sireId = <span class="title function_">uint256</span>(kit.<span class="property">sireId</span>);</span><br><span class="line">    generation = <span class="title function_">uint256</span>(kit.<span class="property">generation</span>);</span><br><span class="line">    genes = kit.<span class="property">genes</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 在 Solidity中，可以让一个函数返回多个值。</p>
<h2 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h2><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  <span class="keyword">function</span> getNum(address _myAddress) <span class="built_in">public</span> <span class="keyword">view</span> <span class="keyword">returns</span> (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在合约中这样使用：</p>
<ol>
<li>获得合约地址（该合约必须为external或者public）</li>
<li>定义一个变量：指向该合约地址的合约对象（之前定义的与之交互的接口对象）</li>
<li>调用该合约对象中的函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">MyContract</span> &#123;</span><br><span class="line">  address <span class="title class_">NumberInterfaceAddress</span> = <span class="number">0xab38</span>...;</span><br><span class="line">  <span class="comment">// ^ 这是FavoriteNumber合约在以太坊上的地址</span></span><br><span class="line">  <span class="title class_">NumberInterface</span> numberContract = <span class="title class_">NumberInterface</span>(<span class="title class_">NumberInterfaceAddress</span>);</span><br><span class="line">  <span class="comment">// 现在变量 `numberContract` 指向另一个合约对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>) public &#123;</span><br><span class="line">    <span class="comment">// 现在我们可以调用在那个合约中声明的 `getNum`函数:</span></span><br><span class="line">    uint num = numberContract.<span class="title function_">getNum</span>(msg.<span class="property">sender</span>);</span><br><span class="line">    <span class="comment">// ...在这儿使用 `num`变量做些什么</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>
<h2 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h2><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multipleReturns</span>(<span class="params"></span>) internal <span class="title function_">returns</span>(<span class="params">uint a, uint b, uint c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processMultipleReturns</span>(<span class="params"></span>) external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  <span class="comment">// 这样来做批量赋值:</span></span><br><span class="line">  (a, b, c) = <span class="title function_">multipleReturns</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者如果我们只想返回其中一个变量:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLastReturnValue</span>(<span class="params"></span>) external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  <span class="comment">// 可以对其他字段留空:</span></span><br><span class="line">  (,,c) = <span class="title function_">multipleReturns</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eatBLT</span>(<span class="params">string sandwich</span>) public &#123;</span><br><span class="line">  <span class="comment">// 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">keccak256</span>(sandwich) == <span class="title function_">keccak256</span>(<span class="string">&quot;BLT&quot;</span>)) &#123;</span><br><span class="line">    <span class="title function_">eat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h2><h3 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p>
<p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi generated by the compiler */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFeedingContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* our contract address on Ethereum after deploying */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFeeding</span> = <span class="title class_">ZombieFeedingContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span></span><br><span class="line"><span class="keyword">let</span> zombieId = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> kittyId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span></span><br><span class="line"><span class="comment">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span></span><br><span class="line"><span class="comment">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span></span><br><span class="line"><span class="keyword">let</span> apiUrl = <span class="string">&quot;https://api.cryptokitties.co/kitties/&quot;</span> + kittyId</span><br><span class="line">$.<span class="title function_">get</span>(apiUrl, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgUrl = data.<span class="property">image_url</span></span><br><span class="line">  <span class="comment">// 一些显示图片的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户点击一只猫咪的时候:</span></span><br><span class="line">$(<span class="string">&quot;.kittyImage&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用我们合约的 `feedOnKitty` 函数</span></span><br><span class="line">  <span class="title class_">ZombieFeeding</span>.<span class="title function_">feedOnKitty</span>(zombieId, kittyId)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听来自我们合约的新僵尸事件好来处理</span></span><br><span class="line"><span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个函数用来显示僵尸:</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</div><div class="article-licensing box"><div class="licensing-title"><p>「区块链」：Solidity-basic</p><p><a href="https://f7ed.com/2020/11/03/solidity-basic/">https://f7ed.com/2020/11/03/solidity-basic/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>f7ed</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-03</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-05-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/blockchain/">blockchain, </a><a class="link-muted" rel="tag" href="/tags/solidity/">solidity </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/qrcode_wechat.jpg" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/f7ed" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/qrcode_alipay.jpg" alt="Alipay"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/05/solidity-advanced/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「区块链」：Solidity-advanced</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/31/unsupervised-learning-pca/"><span class="level-item">「机器学习-李宏毅」:Unsupervised-PCA</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "1667b19d7bcbce405855ea13e004d44e",
            repo: "f7ed.github.io",
            owner: "f7ed",
            clientID: "ec59f5258ac0ec443907",
            clientSecret: "f092b308c3e1b46327481c3547ee0dd7fc1bda10",
            admin: ["f7ed"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/profile.png" alt="f7ed"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">f7ed</p><p class="is-size-6 is-block">热爱可抵漫长岁月。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">139</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:f7edliu@outlook.com" target="_blank" rel="noopener">Email me</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Part-1"><span class="level-left"><span class="level-item">1</span><span class="level-item">Part 1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第2章-合约"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">第2章: 合约</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#版本指令"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">版本指令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第3章-状态变量和整数"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">第3章: 状态变量和整数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#无符号整数-uint"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">无符号整数: uint</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第4章-数学运算"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">第4章: 数学运算</span></span></a></li><li><a class="level is-mobile" href="#第5章-结构体"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">第5章: 结构体</span></span></a></li><li><a class="level is-mobile" href="#第6章-数组"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">第6章: 数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#公共数组"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">公共数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第7章-定义函数"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">第7章: 定义函数</span></span></a></li><li><a class="level is-mobile" href="#第8章-使用结构体和数组"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">第8章: 使用结构体和数组</span></span></a></li><li><a class="level is-mobile" href="#第9章-私有-公共函数"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">第9章: 私有 / 公共函数</span></span></a></li><li><a class="level is-mobile" href="#第10章-函数的更多属性"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">第10章: 函数的更多属性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#返回值"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">返回值</span></span></a></li><li><a class="level is-mobile" href="#函数的修饰符"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">函数的修饰符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第11章-Keccak256-和-类型转换"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">第11章: Keccak256 和 类型转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类型转换"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">类型转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第13章-事件"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">第13章: 事件</span></span></a></li><li><a class="level is-mobile" href="#第14章-Web3-js"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">第14章: Web3.js</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Part-2"><span class="level-left"><span class="level-item">2</span><span class="level-item">Part 2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第2章-映射（Mapping）和地址（Address）"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">第2章: 映射（Mapping）和地址（Address）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Addresses-（地址）"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Addresses （地址）</span></span></a></li><li><a class="level is-mobile" href="#Mapping（映射）"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">Mapping（映射）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第3章-Msg-sender"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">第3章: Msg.sender</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#msg-sender"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">msg.sender</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第4章-Require"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">第4章: Require</span></span></a></li><li><a class="level is-mobile" href="#第5章-继承（Inheritance）"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">第5章: 继承（Inheritance）</span></span></a></li><li><a class="level is-mobile" href="#第6章-引入（Import）"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">第6章: 引入（Import）</span></span></a></li><li><a class="level is-mobile" href="#第7章-Storage与Memory"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">第7章: Storage与Memory</span></span></a></li><li><a class="level is-mobile" href="#第9章-更多关于函数可见性"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">第9章: 更多关于函数可见性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#internal-和-external"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">internal 和 external</span></span></a></li><li><a class="level is-mobile" href="#与其他合约的交互"><span class="level-left"><span class="level-item">2.7.2</span><span class="level-item">与其他合约的交互</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第11章-使用接口"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">第11章: 使用接口</span></span></a></li><li><a class="level is-mobile" href="#第12章-处理多返回值"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">第12章: 处理多返回值</span></span></a></li><li><a class="level is-mobile" href="#第13章-奖励-Kitty-基因"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">第13章: 奖励: Kitty 基因</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#if-语句"><span class="level-left"><span class="level-item">2.10.1</span><span class="level-item">if 语句</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第14章-放在一起"><span class="level-left"><span class="level-item">2.11</span><span class="level-item">第14章: 放在一起</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JavaScript-实现"><span class="level-left"><span class="level-item">2.11.1</span><span class="level-item">JavaScript 实现</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 f7ed</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="f7ed&#039;s GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script>
      var sc_project=12961083;
      var sc_invisible=1;
      var sc_security="ad3fb575";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12961083/0/ad3fb575/1/" alt="real time web analytics"></div></noscript><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>