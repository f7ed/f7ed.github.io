<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「Cryptography-ZKP」: Lec5-The Plonk SNARK - fred&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fred&#039;s blog"><meta name="msapplication-TileImage" content="/img/heart.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fred&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="In this series, I will learn Zero Knowledge Proofs (ZKP) on this MOOC, lectured by Dan Boneh, Shafi Goldwasser, Dawn Song, Justin Thaler and Yupeng Zhang.  Any corrections and advice are welcom"><meta property="og:type" content="blog"><meta property="og:title" content="「Cryptography-ZKP」: Lec5-The Plonk SNARK"><meta property="og:url" content="https://f7ed.com/2023/07/21/zkp-lec5/"><meta property="og:site_name" content="fred&#039;s blog"><meta property="og:description" content="In this series, I will learn Zero Knowledge Proofs (ZKP) on this MOOC, lectured by Dan Boneh, Shafi Goldwasser, Dawn Song, Justin Thaler and Yupeng Zhang.  Any corrections and advice are welcom"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://f7ed.com/gallery/covers/zkp-lec5-banner.png"><meta property="article:published_time" content="2023-07-20T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-15T07:51:12.471Z"><meta property="article:author" content="f7ed"><meta property="article:tag" content="Cryptography"><meta property="article:tag" content="ZKP"><meta property="article:tag" content="SNARKs"><meta property="article:tag" content="KZG"><meta property="article:tag" content="Plonk"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/zkp-lec5-banner.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://f7ed.com/2023/07/21/zkp-lec5/"},"headline":"「Cryptography-ZKP」: Lec5-The Plonk SNARK","image":["https://f7ed.com/gallery/covers/zkp-lec5-banner.png"],"datePublished":"2023-07-20T16:00:00.000Z","dateModified":"2023-08-15T07:51:12.471Z","author":{"@type":"Person","name":"f7ed"},"publisher":{"@type":"Organization","name":"fred's blog","logo":{"@type":"ImageObject","url":"https://f7ed.com/img/f1ed_logo.png"}},"description":"In this series, I will learn Zero Knowledge Proofs (ZKP) on this MOOC, lectured by Dan Boneh, Shafi Goldwasser, Dawn Song, Justin Thaler and Yupeng Zhang.  Any corrections and advice are welcom"}</script><link rel="canonical" href="https://f7ed.com/2023/07/21/zkp-lec5/"><link rel="icon" href="/img/heart.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-M5KG3CQTSF" async></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-M5KG3CQTSF');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="fred's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/liu">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-bars"></i>「Cryptography-ZKP」: Lec5-The Plonk SNARK</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2023-07-20T16:00:00.000Z" title="2023-07-20T16:00:00.000Z">2023-07-21</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2023-08-15T07:51:12.471Z" title="2023-08-15T07:51:12.471Z">2023-08-15</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/Cryptography-ZKP/">Cryptography-ZKP</a></span><span class="level-item"><i class="far fa-clock"></i> 44 minutes read (About 6632 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><article class="message message-immersive is-info">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="message-body">
<i class="fas fa-info-circle mr-2"></i>
    In this <a href="/categories/Cryptography-ZKP">series</a>, I will learn <strong>Zero Knowledge Proofs (ZKP)</strong> on this <a target="_blank" rel="noopener" href="https://zk-learning.org/">MOOC</a>, lectured by <strong>Dan Boneh</strong>, Shafi Goldwasser, Dawn Song, Justin Thaler and Yupeng Zhang. 
<br>Any corrections and advice are welcome. ^ - ^
</div>
</article>

<p><strong>Topics:</strong> </p>
<ul>
<li>Preprocessing SNARK</li>
<li><strong>KZG Poly-Commit Scheme</strong></li>
<li>Proving Properties of committed polys<ul>
<li>ZeroTest</li>
<li>Product Check</li>
<li>Permutation Check</li>
<li>Prescribed Permutation Check</li>
</ul>
</li>
<li><strong>Plonk IOP for General Circuits</strong></li>
</ul>
<span id="more"></span>

<h1 id="What-is-SNARK"><a href="#What-is-SNARK" class="headerlink" title="What is SNARK?"></a>What is SNARK?</h1><p>Before proceeding to today’s topic, let’s review what is SNARK.</p>
<p>Note that this part is well explained in Lecture 2.</p>
<h2 id="preprocessing-NARK"><a href="#preprocessing-NARK" class="headerlink" title="preprocessing NARK"></a>preprocessing NARK</h2><p>NARK is <strong>Non-interactive ARgument of Knowledge.</strong></p>
<p>Given a public arithmetic circuit $C(x,w)\rightarrow \mathbb{F}$ where $x$ is the public statement in $\mathbb{F}^n$ and $w$ is the secret witness in $\mathbb{F}^m$, a <strong>preprocessing (setup) algorithm</strong> </p>
<p>$$<br>S(C)\rightarrow \text{ public parameters } (pp,vp)<br>$$</p>
<p> <u>takes a description of the circuit as inputs</u>, and <u>outputs public parameters</u> $(pp,vp)$ for prover and verifier.</p>
<p>NARK works as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZmOx.png" alt="NARK" style="zoom:33%;" />

<p>A <strong>preprocessing NARK</strong> is a triple of algorithms $(S,P,V)$.</p>
<ul>
<li>$S(C)\rightarrow$ public parameters $(pp,vp)$ for prover and verifier.</li>
<li>$P(pp,x,w)\rightarrow$  proof $\pi$.</li>
<li>$V(vp,x,\pi)\rightarrow$ accept or reject.</li>
</ul>
<p>Note that all algorithms and the adversary have access to a random oracle.</p>
<p>The informal requirements of NARK are completeness and adaptively knowledge soundness. </p>
<p><strong>Completeness</strong> means that <u>an honest prover always convinces the verifier to accept the answer,</u> i.e.</p>

$$
\forall x,w: C(x,w)=0 \text{ then } \operatorname{Pr}[V(vp,x,P(pp,x,w))=\text{accept}]=1
$$



<p>Adaptively <strong>knowledge soundness</strong> means that <u>if the verifier accepts the proof, then the prover must know a witness such that $C(x,w)=0$.</u>  In other words, there exists an extractor $E$ that can extract a valid $w$ from $P$.</p>
<p><strong>Zero-knowledge</strong> suggests that $(C,pp,vp,x,\pi)$ reveals nothing new about $w$. Note that the privacy requirement, i.e. zero knowledge, in NARK is optional. So there is a <u>trivial NARK</u> in which the prover just sends $w$ as proof and the verifier just rerun the circuit and check if $C(x,w)=0$.</p>
<h2 id="SNARK-a-Succinct-ARgument-of-Knowledge"><a href="#SNARK-a-Succinct-ARgument-of-Knowledge" class="headerlink" title="SNARK: a Succinct ARgument of Knowledge"></a>SNARK: a Succinct ARgument of Knowledge</h2><p>SNARK is a <u>NARK (complete and knowledge sound) that is succinct.</u> </p>
<p>zk-SNARK is a SNARK that is also zero knowledge, meaning that the <u>SNARK proof reveals nothing about the witness.</u></p>
<p>A <strong>preprocessing SNARK</strong> is a triple of algorithms $(S,P,V)$.</p>
<ul>
<li>$S(C)\rightarrow$ public parameters $(pp,vp)$ for prover and verifier.</li>
<li>$P(pp,x,w)\rightarrow$  <strong>short</strong> proof $\pi$; $\text{len}(\pi)=\text{sublinear}(|w|)$.</li>
<li>$V(vp,x,\pi)\rightarrow$ <strong>fast to verify</strong>; $\text{time}(V)=O_\lambda(|x|,\text{sublinear}(|C|))$.</li>
</ul>
<p>SNARK requires the <strong>length of proof</strong> to be <u>sublinear in the length of the witness,</u> and the <strong>verify runtime</strong> to be <u>linear in the statement and sublinear in the size of the circuit.</u></p>
<p>Being linear in the statement $x$ means that the verifier at least read the statements.</p>
<p>Furthermore, a <strong>strongly succinct preprocessing NARK</strong> is not only sublinear <u>but logarithmic in the size of the circuit.</u></p>
<ul>
<li>$S(C)\rightarrow$ public parameters $(pp,vp)$ for prover and verifier.</li>
<li>$P(pp,x,w)\rightarrow$  <strong>short</strong> proof $\pi$; $\text{len}(\pi)=O_\lambda(\log(|C|))$.</li>
<li>$V(vp,x,\pi)\rightarrow$ <strong>fast to verify</strong>; $\text{time}(V)=O_\lambda(|x|,\log (|C|))$.</li>
</ul>
<p>Note that the verifier runtime is logarithmic in the size of the circuit, which implies that the <u>verifier even does not know what the underlying circuit is.</u></p>
<p>An <strong>insight</strong> is that the <u>verifier parameter $vp$ is the short “summary” of the circuit</u> so the verifier is able to verify the evaluations of the circuit at an arbitrary input $x$.</p>
<p>That’s the reason why we need the preprocessing or setup.</p>
<p>It is worth noting that the trivial SNARK is not a SNARK.</p>
<h2 id="Types-of-preprocessing-Setup"><a href="#Types-of-preprocessing-Setup" class="headerlink" title="Types of preprocessing Setup"></a>Types of preprocessing Setup</h2><p>The setup for a circuit $C$ is an algorithm $S(C;r)\rightarrow \text{ public parameters}(pp,vp)$, which takes the circuit and random bits as inputs and generates public parameters for the prover and the verifier.</p>
<p>The types of setup are more detailed.</p>
<ul>
<li><strong>trusted setup per circuit:</strong> random $r$ must be <u>kept secret from the prover</u>.<ul>
<li>$S(C;r)$</li>
</ul>
</li>
<li><strong>trusted but universal (updatable) setup:</strong> secret $r$ is <u>independent of $C$.</u><ul>
<li>$S=(S_{init},S_{index})$</li>
<li>$S_{init}(\lambda;r)\rightarrow gp$: onetime setup, secret $r$</li>
<li>$S_{index}(gp,C)\rightarrow (pp,vp)$: deterministic algorithm</li>
</ul>
</li>
<li><strong>transparent setup:</strong> does not use secret data<ul>
<li>$S(C)$</li>
</ul>
</li>
</ul>
<p>In the <strong>trusted setup</strong>, random $r$ must be kept secret from the prover, meaning that it has to be run for every circuit.</p>
<p>Once the <u>prover learns $r$, it allows the prover to prove false statements.</u> In practice, $r$ will be destroyed so that nobody can ever know $r$. Sometimes, it is called the <strong>trusted setup ceremony</strong>.</p>
<p>In the <strong>trusted but universal setup</strong>, it splits the setup into two parts. $S_{init}$ is a <strong>one-time setup</strong> that <u>does not take the circuit as input</u> and generates <u>global parameters</u> $gp$. Note that $r$ is required to be secret as well.</p>
<p>Then $S_{index}$ is a <u>deterministic algorithm executed for every circuit</u> so it <u>takes the circuit and $gp$</u> as inputs and generates public parameters for the prover and the verifier.</p>
<p>In the <strong>transparent setup</strong>, $S(C)$ does not use secret data.</p>
<h1 id="General-Paradigm-for-Building-SNARK"><a href="#General-Paradigm-for-Building-SNARK" class="headerlink" title="General Paradigm for Building SNARK"></a>General Paradigm for Building SNARK</h1><p>The general paradigm for building SNARK is made up of two steps.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZMTO.png" alt="General paradigm for building SNARK" style="zoom:33%;" />

<p>One is the <strong>functional commitment scheme</strong>, which is a cryptographic object that depends on some assumptions.</p>
<p>The other is the compatible <strong>interactive oracle proof (IOP)</strong>. IOP is an information-theoretic object, which <u>provides unconditional security without any assumptions.</u></p>
<p>To be precise, they are not separate steps. </p>
<p>For example, <strong>using poly-IOP</strong>, we can <u>boost polynomial functional commitment for $\mathbb{F}_p^{(\le d)}[X]$ to build SNARK for any circuit $C$ where $|C|&lt;d$.</u></p>
<h2 id="Polynomial-Commitments"><a href="#Polynomial-Commitments" class="headerlink" title="Polynomial Commitments"></a>Polynomial Commitments</h2><p>Review the polynomial commitments introduced in the last lecture.</p>
<p>Prover commits to a univariate polynomial $f(X)$ in $\mathbb{F}_p^{(\le d)}[X]$ where the variable $X$ has degree at most $d$.</p>
<p>Later the verifier can request to know the evaluation of this polynomial at a specific point. </p>
<p>In other words, for public $u,v\in \mathbb{F}_p$, the <u>prover can convince the verifier that the committed polynomial satisfies</u> </p>
<p>$$<br>f(u)=v \text{ and deg}(f)\le d<br>$$</p>
<p>Note that the verifier has the upper bound of the degree $d$, the commitment received from the prover, and $u,v$.</p>
<p>In SNARK, the evaluation proof size and verifier time should be logarithmic in the degree, i.e. $O_\lambda(\log d)$.</p>
<h3 id="Equality-Test-Protocol"><a href="#Equality-Test-Protocol" class="headerlink" title="Equality Test Protocol"></a>Equality Test Protocol</h3><p>Recall the observation that if $p,q$ are univariate polynomials of degree at most $d$, then  $\operatorname{Pr}_{r\overset{\$}\leftarrow \mathbb{F}}[p(r)=q(r)]\le d/p$. </p>
   If $f(r)=g(r)$ for a random $r \overset{\$}\leftarrow \mathbb{F}_p$, then $f=g$ w.h.p.

Having the polynomial commitments, we can construct the equality test protocol as follows.  

<img src="https://s1.ax1x.com/2023/07/21/pCbZK0K.png" alt="Equality Test Protocol" style="zoom:33%;" />

<ol>
<li>Prover has committed to two polynomial $f,g$, so verifier has two commitments depicted in two boxes.</li>
<li>Verifier samples a random coin $r$ in $\mathbb{F}_p$ and sends to prover.<br>Hence, it is a public coin.</li>
<li>Prover sends the evaluations $y,y’$ and proof that $y=f(r)$ and $y’=g(r)$.</li>
<li>Verifier accepts if $y=y’$ and the proof is valid.</li>
</ol>
<h3 id="Fiat-Shamir-Transform"><a href="#Fiat-Shamir-Transform" class="headerlink" title="Fiat-Shamir Transform"></a>Fiat-Shamir Transform</h3><p>Note that the equality teat protocol is interactive but the verifier just sends coins to prover.</p>
<p>A solution to making it a SNARK (non-interactive) is the <strong>Fiat-Shamir transform</strong>, which <u>can render a public-coin interactive protocol non-interactive.</u></p>
<p>Let $H:M\rightarrow R$ be a cryptographic hash function.</p>
<p>The <strong>main idea</strong> is <u>having prover generates verifier’s random bits on its own using $H$,</u> i.e. $r\leftarrow H(x)$.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZum6.png" alt="Fiat-Shamir Transform" style="zoom:43%;" />

<p>Prover and verifier can compute $r\leftarrow H(x)$, making it <strong>non-interactive.</strong></p>
<p>The <strong>completeness</strong> is evident and one has to <u>prove knowledge soundness.</u></p>
<p><font color=blue><u><b>Thm via Fiat-Shamir Transform:</b></u></font> </p>
<p>This is a SNARK if ( i ) $d/p$ is negligible where $f,g\in \mathbb{F}_p^{(\le d)}[X]$, and ( ii ) $H$ is modeled as a random oracle.</p>
<p>In practice, we use SHA256 as $H$.</p>
<p>The <strong>succinctness</strong> holds by a succinct poly commitment scheme.</p>
<p>Note that it is <strong>not zk</strong> since verifier learns the value of $f(r),g(r)$ that he didn’t know before.</p>
<hr>
<p>In this blog, we’ll introduce a specific polynomial commitment scheme — <strong>KZG’10</strong> with a trusted setup. </p>
<p>KZG requires <strong>a trusted but universal setup</strong> that generates global parameters once, then it can commit to an arbitrary polynomial of bounded degree $d$.</p>
<h2 id="mathcal-F-IOP"><a href="#mathcal-F-IOP" class="headerlink" title="$\mathcal{F}$-IOP"></a>$\mathcal{F}$-IOP</h2><p>Having the functional commitments, we can build SNARKs for some circuits, e.g. zero test, equality test.</p>
<p>But with $\mathcal{F}$-IOP, we can <u>boost functional commitment to build SNARK for any circuit $C(x,w)$.</u></p>
<p>Hence, $\mathcal{F}$-IOP is <strong>a proof system</strong> that proves $\exist w:C(x,w)=0$ as follows. </p>
<ul>
<li><p>Setup: The setup algorithm outputs public parameters for prover and verifier where $vp$ <u>contains a number of oracles for functions in $\mathcal{F}$.</u><br>Verifier can ask the oracle for evaluations at some points.<br>The <u>oracles will be replaced to functional commitment schemes in SNARKs.</u></p>
  <img src="https://s1.ax1x.com/2023/07/21/pCbZe61.png" alt="Setup" style="zoom:33%;" />
</li>
<li><p>IP proving $C(x,w)=0$: In each round, prover sends an oracle for a function $f_i$ which later on the verifier can evaluate at any point of his choice.<br>Likewise, the oracles will be <u>compiled to the commitment scheme when instantiating actual SNARKs.</u></p>
  <img src="https://s1.ax1x.com/2023/07/21/pCbZ1te.png" alt="Public-coin IP" style="zoom:33%;" />


</li>
</ul>
<p><font color=blue><u><b><i>Properties:</i></b></u></font></p>
<ul>
<li>Complete:  if $\exist w:C(x,w)=0$ then $\operatorname{Pr}[\text{verifier accepts}]=1$. </li>
<li>(Unconditional) knowledge sound (as an IOP): extractor is given $(x,f_1, r_1, \dots, r_{t-1},f_t)$ and outputs $w$.<br>Note that the <strong>given functions are in clear</strong> since the <u>functional commitments are SNARKs so the extractor can extract the functions from the commitments.</u></li>
<li>Optional: zero knowledge for a zk-SNARK</li>
</ul>
<h1 id="KZG-Poly-Commit-Scheme"><a href="#KZG-Poly-Commit-Scheme" class="headerlink" title="KZG Poly-Commit Scheme"></a>KZG Poly-Commit Scheme</h1><p>Let’s introduce today’s highlight, KZG polynomial commitment scheme [Kate-Zaverucha-Goldberg’2010].</p>
<h2 id="KZG-A-Binding-PSC"><a href="#KZG-A-Binding-PSC" class="headerlink" title="KZG: A Binding PSC"></a>KZG: A Binding PSC</h2><p>Fixed a group $\mathbb{G}={0,G,2\cdot G, 3\cdot G,\dots, (p-1)\cdot G}$ of order $p$.</p>
<h3 id="Commitment"><a href="#Commitment" class="headerlink" title="Commitment"></a>Commitment</h3><p>It requires a <strong>trusted but universal setup.</strong></p>
<ul>
<li>$\text{setup}(1^\lambda)\rightarrow gp$<ul>
<li>Sample random $\tau\in \mathbb{F}_p$</li>
<li>$gp=(H_0=G,H_1=\tau\cdot G, H_2=\tau^2\cdot G, \dots, H_d=\tau^d \cdot G)\in \mathbb{G}^{d+1}$.</li>
<li>delete $\tau$!!</li>
</ul>
</li>
<li>$\text{commit}(gp,f)\rightarrow \text{com}_f$ where $\text{com}_f=f(\tau)\cdot G \in \mathbb{G}$<ul>
<li>$f$ as prover parameter</li>
<li>$\text{com}_f$ as verifier parameter</li>
</ul>
</li>
</ul>
<p>The setup generates global parameters $gp$ in which the random $\tau$ used must be destroyed. </p>
<p>Then prover <u>can use $gp$ to generate the commitment for any specific polynomial</u> $f\in \mathbb{F}_p^{(\le d)}[X]$.</p>
<p>It is worth noting the <u>prover can compute $f(\tau)\cdot G$ without knowing $\tau$.</u></p>
<p>It can be evaluated by $gp$:</p>
<p>$$<br>\begin{aligned}f(X)&amp; =f_0+f_1X+\dots+f_d X^d \ \text{com}_f &amp;= f_0 \cdot H_0 +\dots f_d\cdot H_d \ &amp;=f_0\cdot G + f_1\tau \cdot G +f_2 \tau^2\cdot G +\cdots \ &amp;= f(\tau)\cdot G\end{aligned}<br>$$</p>
<p>where $f_0,\dots, f_d$ are coefficients of the polynomial.</p>
<p>This is a binding commitment but <strong>not hiding</strong> since it reveals $f(\tau)\cdot G$.</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>After committing to $f$, verifier can request for evaluations at a specific point.</p>
<p>For public $u,v\in \mathbb{F}_p$, the prover can convince the verifier that the committed polynomial satisfies $f(u)=v$.</p>
<p>The proof hinges on some <u>cute algebraic properties:</u> </p>
<ul>
<li>$f(u)=v$ iff</li>
<li>$u$ is a root of $\hat{f}=f-v$ iff</li>
<li>$(X-u)$ divides $\hat{f}$ iff</li>
<li>exists $q\in \mathbb{F}_p[X]$ s.t. $q(X)\cdot (X-u)=f(X)-v$</li>
</ul>
<p>As a result, we can construct <strong>an equality test</strong> on two polynomials to verify the original claim $f(u)=v$.</p>
<p>The whole idea is depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZlkD.png" alt="Evaluation at a specific point" style="zoom:33%;" />

<p><font color=blue><u><b>Eval:</b></u></font> </p>
<ul>
<li><strong>Prover</strong><ul>
<li>compute the quotient polynomial $q(X)$ and $\text{com}_q=q(\tau)\cdot G$ as the commitment.</li>
<li>send the proof $\pi:=\text{com}_q\in \mathbb{G}$</li>
<li>Note that the proof is <u>just one group element</u>, which is const size better than logarithmic in $d$.</li>
</ul>
</li>
<li><strong>Verifier</strong><ul>
<li>accept if $(\tau-u)\cdot \text{com}_q=\text{com}_f -v\cdot G$</li>
<li>The equality test for $(X-u)q(X)\cdot G=(f(X)-v)\cdot G$ can be checked by the random $\tau$.</li>
</ul>
</li>
</ul>
<p>It is worth noticing that $\tau$ is secret.</p>
<p> But verifier can use a “pairing” to do the above computation with only $H_0,H_1$ from $gp$, which is <u>a fast computation</u> for <strong>verifier</strong>.</p>
<p>As for the <strong>prover</strong>, <u>computing the quotient is indeed an expensive computation</u> for large $d$.</p>
<h2 id="Generalizations"><a href="#Generalizations" class="headerlink" title="Generalizations"></a>Generalizations</h2><p>There are two ways to generalize KZG.</p>
<ul>
<li>[PST’13] Can use KZG to <u>commit to $k$-variate polynomials.</u></li>
<li><strong>Batch proofs</strong>: Can <u>commit to $n$ polynomials</u> and provide a batch proof for multiple evaluations.<ul>
<li>suppose verifier has commitments $\text{com}_{f_1},\dots, \text{com}_{f_n}$ </li>
<li>prover wants to prove $f_i(u_{i,j})=v_{i,j}$ for $i\in [n],j\in[m]$</li>
<li>→ batch proof $\pi$ is <u>only one group element !</u></li>
</ul>
</li>
</ul>
<h2 id="Properties-linear-time-commitment"><a href="#Properties-linear-time-commitment" class="headerlink" title="Properties: linear time commitment"></a>Properties: linear time commitment</h2><p>One wonderful property of KZG is the <u>prover’s runtime for commitment is linear in the degree $d$.</u></p>
<p>There are two ways to represent a polynomial $f(X)$ in $\mathbb{F}_p^{(\le d)}[X]$:</p>
<ul>
<li><strong>Coefficient representation:</strong><br>$f(X)=f_0+f_1X+\dots +f_d X^d$.<ul>
<li>computing $\text{com}_f=f_0\cdot H_0 +\dots +f_d\cdot H_d$ <u>takes linear time in $d$.</u></li>
</ul>
</li>
<li><strong>Point-value representation:</strong><br>$((a_0,f(a_0)),\dots,(a_d,f(a_d))$<ul>
<li>computing $\text{com}_f$ naively: <u>construct coefficients $(f_0,f_1,\dots, f_d)$ takes time $O(d\log d)$</u> using Number Theoretic Transform (NTT).</li>
</ul>
</li>
</ul>
<p>Using the point-value representation, the naive way of constructing coefficients takes time $O(d\log d)$ yet <u>we want it linear in $d$.</u></p>
<p>A better way to compute the commitment with point-value representation is the <strong>Lagrange interpolation.</strong></p>
  
$$
f(\tau)=\sum_{i=0}^d \lambda_i (\tau)\cdot f(a_i) \\ \text{where } \lambda_i(\tau)=\frac{\prod_{j=0,j\ne i}^d (\tau -a_j)}{\prod _{j=0,j\ne i}^{d}(a_i-a_j)}\in \mathbb{F}_p
$$

  

<p>One can <u>transform $gp$ into Lagrange form $\hat{gp}$ by a linear map</u>, not involving any secrets so that anyone can fulfill this transformation.</p>
  
$$
\hat{gp}=(\hat{H}_0=\lambda_0(\tau)\cdot G,\hat{H}_1=\lambda_1(\tau)\cdot G,\dots, \hat{H_d}=\lambda_d(\tau)\cdot G)
$$

  

<p>Now, prover can <strong>in linear time</strong> computes the commitment from the point-value representation as follows.</p>
  
$$
\text{com}_f=f(\tau)\cdot G=f(a_0)\cdot \hat{H}_0+\dots +f(a_d)\cdot \hat{H}_d
$$

  

<p>To sum up, prover can compute the commitment in linear time from the coefficient representation or the point-value representation.</p>
<h3 id="Multi-point-Proof-Generation"><a href="#Multi-point-Proof-Generation" class="headerlink" title="Multi-point Proof Generation"></a>Multi-point Proof Generation</h3><p>Let $\Omega\subseteq \mathbb{F}_p$ and $|\Omega|=d$.</p>
<p>Consider such a case in which  prover has some $f(X)$ in $\mathbb{F}_p^{(\le d)}[X]$ and needs evaluation proofs $\pi_a\in G$ <strong>for all</strong> $a\in \Omega$.</p>
<p>When it comes to generate evaluation proofs for multi-points, prover <u>naively takes time $O(d^2)$ for $d$ proofs</u>, each takes time $O(d)$.</p>
<p><u><b>Feist-Khovratovich (FK2020) algorithm</b></u> optimize to</p>
<ul>
<li>time $O(d\log d)$ if $\Omega$ is <u>a multiplicative subgroup</u></li>
<li>time $O(d\log^2 d)$ otherwise.</li>
</ul>
<h3 id="The-Dory-polynomial-commitment"><a href="#The-Dory-polynomial-commitment" class="headerlink" title="The Dory polynomial commitment"></a>The Dory polynomial commitment</h3><p>The difficulties with KZG lies in two parts</p>
<p>One has to require trusted setup for $gp$, and $gp$ size is linear in $d$.</p>
<p>Dory (eprint/2020/1274) is proposed to get over the trusted setup.</p>
<ul>
<li><strong>transparent setup:</strong> no secret randomness in the setup</li>
<li>$\text{com}_f$ is a single group element (independent of degree $d$ )</li>
<li>eval proof size for $f\in \mathbb{F}_p^{(\le d)}[X]$ is $O(\log d)$ group elements.<br>Note the eval proof size is <u>constant</u> size in original KZG.</li>
<li>eval verify time is $O(\log d)$<br>Note the eval verify time is <u>constant</u>.</li>
<li>prover time is $O(d)$</li>
</ul>
<h2 id="Applications-vector-commitment"><a href="#Applications-vector-commitment" class="headerlink" title="Applications: vector commitment"></a>Applications: vector commitment</h2><p>Polynomial Commitment Scheme (PCS) have many applications.</p>
<p>One is to <u>perform a drop-in replacement for Merkle trees.</u></p>
<p>The idea is to <u>view the vector $(u_1,\dots, u_k)\in \mathbb{F}_p^{(\le d)}$ as a function</u> $f$ such that $f(i)=u_i$ for $i=1,\dots, k$, then prover can commits to this polynomial.</p>
<p>Instead of proving the revealed entry is consistent with the committed vector, prover can <u>generate evaluation proof</u> that $f(2)=a,f(4)=b$ as depicted follows.</p>
<p>The proof $\pi$ is a single group element (using batch proof) that is shorter than a Merkle proof.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZ3fH.png" alt="PCS as vector commitment" style="zoom:33%;" />



<h1 id="Proving-properties-of-committed-polynomials"><a href="#Proving-properties-of-committed-polynomials" class="headerlink" title="Proving properties of committed polynomials"></a>Proving properties of committed polynomials</h1><p>Having PCS, not only verifier can query evaluations of a committed polynomial, but <u>prover can convince verifier that the committed polynomials $f,g$ satisfy some properties</u>, e.g. equality test.</p>
<p>It can be summed up in the following process.</p>
<ul>
<li>Start: Prover has functions $f,g$ in clear and verifier has the corresponding commitments via PCS.</li>
<li>Verifier samples a random $r\in \mathbb{F}_p$.</li>
<li>Prover computes a related polynomial $q$ and commits to it.</li>
<li>Verifier can query $f,g,q$ at point $x$ and accept if valid.<br>Note that when we say verifier query a committed polynomial $f(x)$, it means verifier sends $x$ to prover who responds with $f(x)$ and eval proof $\pi$. (described in here[link])</li>
</ul>
<img src="https://s1.ax1x.com/2023/07/21/pCbZGpd.png" alt="Untitled" style="zoom:33%;" />

<h2 id="Polynomial-Equality-Testing-with-KZG"><a href="#Polynomial-Equality-Testing-with-KZG" class="headerlink" title="Polynomial Equality Testing with KZG"></a>Polynomial Equality Testing with KZG</h2><p>As described above, we can construct equality test for two committed polynomials.</p>
<p>But for KZG, $f=g$ <strong>if and only if</strong> $\text{com}_f=\text{com}_g$, resulting that <u>verifier can tell if $f=g$ on its own.</u></p>
<p>But prover is needed to <strong>test equality of computed polynomials.</strong></p>
<p>For example, verifier has four individual commitments to $f,g_1,g_2,g_3$  where all four are in $\mathbb{F}_p^{(\le d)}[X]$ to test $f=g_1g_2g_3$.</p>
<p>Then verifier queries all four polynomials at a random point $r\overset{$}\leftarrow \mathbb{F}_p$ and tests equality.</p>
<p>It is complete and sound assuming $3d/p$ is negligible since $\text{deg}(g_1g_2g_3)\le 3d$.</p>
<h2 id="Summary-of-Proof-Gadgets-for-Univariates"><a href="#Summary-of-Proof-Gadgets-for-Univariates" class="headerlink" title="Summary of Proof Gadgets for Univariates"></a>Summary of Proof Gadgets for Univariates</h2><p>In order to construct Poly-IOPs for an arbitrary circuit.</p>
<p>In this section, we’ll introduce some important <strong>proof gadgets for univariates.</strong></p>
<p>Let $\Omega$ be some subset of $\mathbb{F}_p$ of size $k$.</p>
<p>Let $f\in \mathbb{F}_p^{(\le d)}[X]$ where $d\ge k$ and verifier has the commitment to $f$.</p>
<p>We can construct <u>efficient Poly-IOPs</u> for the following tasks.</p>
<ul>
<li><strong>Zero Test</strong>: prove that $f$ is identically zero on $\Omega$.</li>
<li><strong>Sum Check</strong>: prove that $\sum_{a\in \Omega}f(a)=0$.</li>
<li><strong>Prod Check</strong>: prove that $\prod_{a\in \Omega}f(a)=1$.<ul>
<li>→ prove for rational functions that $\prod_{a\in \Omega}f(a)/g(a)=1$</li>
</ul>
</li>
<li><strong>Permutation Check</strong>: prove that $g(\Omega)$ is the same as $f(\Omega)$, just permuted.</li>
<li><strong>Prescribed Permutation Check</strong>: prove that $g(\Omega)$ is the same as $f(\Omega)$, permuted by the prescribed $W$.</li>
</ul>
<h2 id="Vanishing-Polynomial"><a href="#Vanishing-Polynomial" class="headerlink" title="Vanishing Polynomial"></a>Vanishing Polynomial</h2><p>Before staring, let’s introduce the vanishing polynomial.</p>
 <article class="message is-info"> <div class="message-header"> 

<p><strong>Def: Vanishing Polynomial of $\Omega$:</strong></p>
 </div> <div class="message-body"> 

<p>The vanishing polynomial of $\Omega$ is </p>
<p>$$<br>Z_\Omega(X):=\prod_{a\in \Omega}(X-a)<br>$$</p>
<p>such that $\text{deg}(Z_\Omega)=k$.</p>
 </div> </article> 

<p>By definition, the <u>vanishing polynomial is a univariate polynomial to be $0$ everywhere on subset $\Omega$.</u> </p>
<p>We can construct <strong>a cute vanishing polynomial</strong> by constructing a special subset $\Omega$.</p>
<p>Let $\omega\in \mathbb{F}_p$ be a primitive $k$-th root of unity so that $\omega ^k=1$.</p>
  If $\Omega=\{1,\omega, \omega^2, \dots, \omega^{k-1}\}\subseteq \mathbb{F}_p$ then $Z_\Omega(X)=X^k-1$.  

<p>Then for $r\in \mathbb{F}_p$, <u>evaluating $Z_\Omega(r)$ takes $\le 2\log_2{k}$ field operations</u> by repeated squaring algorithm.</p>
<p>It’s super fast.</p>
  In the following tasks, we fix $\Omega=\{1,\omega, \omega^2, \dots, \omega^{k-1}\}$.  

<h2 id="ZeroTest-on-Omega"><a href="#ZeroTest-on-Omega" class="headerlink" title="ZeroTest on $\Omega$"></a>ZeroTest on $\Omega$</h2><p>In zero test, prove wants to convince verifier that $f$ is identically zero on $\Omega$.</p>
<p>We build zero test by the following lemma.</p>
<p><font color=blue><u><b>Lemma:</b></u></font> </p>
<p>$f$ is zero on $\Omega$ if and only if $f(X)$ is divisible by $Z_{\Omega}(X)$.</p>
<p>The IOP of zero test is depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZY6I.png" alt="IOP for zero test." style="zoom:33%;" />



<ol>
<li><p><strong>Prover</strong> computes the quotient polynomial $q(X)=f(X)/Z_{\Omega}(X)$ and commits to this polynomial.</p>
<p> Note that with KZG prover can only commits to a polynomial in $\mathbb{F}_p^{(\le d)}$ rather than a rational functions.</p>
</li>
<li><p><strong>Verifier</strong> samples a random $r\in \mathbb{F}_p$.</p>
</li>
<li><p><strong>Verifier</strong> query $q(X)$ and $f(X)$ at point $r$ to learn $q(r)$ and $f(r)$. And verifier evaluates $Z_\Omega(r)$ by itself.</p>
</li>
<li><p><strong>Verifier</strong> accepts if $f(r)=q(r)\cdot Z_\Omega(r)$ since it implies $f(X)=q(X)\cdot Z_\Omega(X)$ w.h.p.</p>
</li>
</ol>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>This protocol is complete and sound assuming $d/p$ is negligible.</p>
<p><font color=blue><u><b>Costs:</b></u></font> </p>
<ul>
<li><strong>Verifier time</strong>: $O(\log k)$ for evaluating $Z_\Omega(r)$ plus two poly queries (that can be batch into one)</li>
<li><strong>Prover time</strong>: dominated by the time to compute $q(X)$ and then commit to $q(X)$.</li>
</ul>
<h2 id="Product-Check-on-Omega"><a href="#Product-Check-on-Omega" class="headerlink" title="Product Check on $\Omega$"></a>Product Check on $\Omega$</h2><p>We omit the details of sum check and jump to the product check since they are nearly the same.</p>
<p>Product check is a useful gadget to construct the permutation check introduced later.</p>
<p>In product check, prover wants to convince verifier that the products of all evaluations over $\Omega$ equals to $1$, i.e. </p>
<p>$$<br>\prod_{a\in \Omega}f(a)=1<br>$$</p>
<p>We construct a degree-$k$ polynomial to prove it.</p>
<p>Set $t\in \mathbb{F}_p^{(\le k)}[X]$ to be the <u>degree-$k$ polynomial</u> such that</p>
<p>$$<br>\begin{aligned}t(1)&amp;=f(1), \ t(\omega^s)&amp;=\prod_{i=0}^s f(\omega^i) \text{ for }s=1,\dots, k \end{aligned}<br>$$</p>
<p>Note that a degree-$k$ polynomial can be uniquely specified by $k+1$ points.</p>
<p>Then $t(\omega^i)$ <u>evaluates the prefix-products as follows.</u></p>
<ul>
<li>$t(\omega)=f(1)\cdot f(\omega)$,</li>
<li>$t(\omega^2)=f(1)\cdot f(\omega)\cdot f(\omega^2)$</li>
<li>… …</li>
<li>$t(\omega^{k-1})=\prod_{a\in \Omega}f(a)=1$</li>
</ul>
<p>We can represent prefix-product <u>in a iterative way:</u></p>
<p>$$<br>t(\omega\cdot x)=t(x)\cdot f(\omega \cdot x) \text{ for all }x\in \Omega<br>$$</p>
<p>As a result, we can do the product check by the following lemma, which can be <u>proved with the evaluation proof and a zero test.</u></p>
<p><font color=blue><u><b>Lemma:</b></u></font>  If </p>
<p>( i ) $t(\omega^{k-1})=1$ and </p>
<p>( ii ) $t(\omega\cdot x)-t(x)\cdot f(\omega\cdot x)=0$ for all $x\in \Omega$</p>
<p>then $\prod_{a\in \Omega}f(a)=1$.</p>
<p>The IOP for product check is depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZtXt.png" alt="IOP for product check" style="zoom:33%;" />



<p>We can split it two parts:</p>
<ul>
<li><strong>Evaluation proof</strong> to prove $t(\omega^{k-1})=1$<ul>
<li>Prover construct $t(X)\in \mathbb{F}_p^{(\le k)}$ and <u>commits</u> to it.</li>
<li>Verifier <u>queries</u> $t(X)$ at $\omega^{k-1}$.</li>
<li><u>check1:</u> Verifier checks that if $t(\omega^{k-1})=1$.</li>
<li><u>proof size:</u> one commit, one evaluation.</li>
</ul>
</li>
</ul>
<p>Let  $t_1(X)=t(\omega\cdot X)-t(X)\cdot f(\omega\cdot X)$.</p>
<ul>
<li><strong>Zero test</strong> to prove $t_1$ is zero on $\Omega$.<br>Recall the lemma that $t_1$ is zero on $\Omega$ iff $Z_{\Omega}(X)$ divides $t_1(X)$.<ul>
<li>Prover computes the quotient polynomial $q(X)=t_1(X)/(X^{k}-1)\in \mathbb{F}_p^{(\le d)}$ and <u>commits</u> to it.</li>
<li>Verifier samples a random $r\in \mathbb{F}_p$ and need to learn $t_1(r)$ and $q(r)$.<ul>
<li>Verifier <u>queries</u> $q(X)$ at $r$.</li>
<li>Verifier <u>queries</u> $t(X)$ at $\omega r$, and $r$.</li>
<li>Verifier <u>u</u> $f(X)$ at $\omega r$.</li>
</ul>
</li>
<li>Verifier computes $r^{k}-1$ in time $O(\log k)$.</li>
<li><u>check2:</u> Verifier checks if $t(\omega\cdot r)-t(\omega)\cdot f(\omega\cdot r)=q(r)\cdot (r^k-1)$.</li>
<li><u>proof size:</u> one commit, four evaluations.</li>
</ul>
</li>
</ul>
<p>Note that it is a public-coin interactive protocol that can be rendered non-interactive via Fiat-Shamir Transform.</p>
<p>To sum up, the <strong>proof size</strong> is made up of <u>two commits and five evaluations</u> (can be batched into a single group element).</p>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>This protocol is complete and sound assuming $2d/p$ is negligible.</p>
<p>( $t(X)\cdot f(\omega\cdot X)$ has degree at most $2d$ ).</p>
<p>It takes <strong>verifier</strong> $O(\log k)$ time to compute $r^{k-1}-1$.</p>
<p>It takes <strong>prover</strong> $O(k\log k)$ time to compute $t(X)$ and $q(X)$ using the naive way that constructs the coefficients from the point-value representation. </p>
<hr>
<p>Likewise, it works to <strong>prove the products on rational functions:</strong></p>
<p>$$<br>\prod_{a\in \Omega}(f/g)(a)=1<br>$$</p>
<p>We construct a similar degree-$k$ polynomial to prove it.</p>
<p>Set $t\in \mathbb{F}_p^{(\le k)}[X]$ to be the <u>degree-$k$ polynomial</u> such that</p>
<p>$$<br>\begin{aligned}t(1)&amp;=f(1)/g(1), \ t(\omega^s)&amp;=\prod_{i=0}^s f(\omega^i)/g(\omega^i) \text{ for }s=1,\dots, k \end{aligned}<br>$$</p>
<p>We write the prefix-product in an iterative way:</p>
<p>$$<br>t(\omega\cdot x)=t(x)\cdot \frac{f(\omega \cdot x)}{g(\omega\cdot x)} \text{ for all }x\in \Omega<br>$$</p>
<p>Then we can prove the following two parts to fulfill the product check.</p>
<p><font color=blue><u><b>Lemma:</b></u></font> If </p>
<p>( i ) $t(\omega^{k-1})=1$ and </p>
<p>( ii ) $t(\omega\cdot x)\cdot g(\omega \cdot x)-t(x)\cdot f(\omega\cdot x)=0$ for all $x\in \Omega$</p>
<p>then $\prod_{a\in \Omega}f(a)/g(a)=1$.</p>
<p>Note that the <strong>proof size</strong> is <u>two commits and six evaluations.</u></p>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>This protocol is complete and sound assuming $2d/p$ is negligible.</p>
<p>Compared to the original prod-check, the <strong>one extra evaluation</strong> comes from the query to $g(X)$ at $\omega\cdot r$. </p>
<h2 id="Permutation-Check"><a href="#Permutation-Check" class="headerlink" title="Permutation Check"></a>Permutation Check</h2><p>Let $f,g$ be polynomials in $\mathbb{F}_p^{(\le d)}[X]$.</p>
<p>Verifier has commitments to $f$ and $g$.</p>
<p>In permutation check, that <strong>goal</strong> is that prover wants to prove that $(f(1),f(\omega),f(\omega^2),\dots, f(\omega^{k-1})\in \mathbb{F}_p^k$ is a <strong>permutation</strong> of $(g(1),g(\omega),g(\omega^2),\dots, g(\omega^{k-1}))\in \mathbb{F}_p^k$.</p>
<p>It means to prove that $g(\Omega)$ is the same as $f(\Omega)$, just permuted.</p>
<p>The <strong>main idea</strong> is to construct auxiliary polynomials that have the evaluations as its root.</p>
<p>Let $\hat{f}(X)=\prod_{a\in \Omega}(X-f(a))$ and $\hat{g}(X)=\prod_{a\in \Omega}(X-g(a))$.</p>
<p><u>Then $\hat{f}(X)=\hat{g}(X)$ if and only if $g$ is a permutation of $f$ on $\Omega$.</u></p>
<p>The <strong>thing to notice</strong> is that prover <strong>cannot</strong> just commits to $\hat{f}$ and $\hat{g}$, then verifier checks if $\hat{f}(r)=\hat{g}(r)$.</p>
<p>Because there is a missed proof that $\hat{f}$ is honestly constructed by the committed $f$. </p>
<p>Instead, prover is needed to prove $\hat{f}(r)=\hat{g}(r)$ by <u>performing a product check on a rational function</u> $\frac{r-f(X)}{r-g(X)}$.</p>
<p>The IOP for permutation check is depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZUnP.png" alt="IOP for permutation check" style="zoom:33%;" />



<p>Let’s elaborate on the details.</p>
<ul>
<li><u>Start</u>: Prover has functions $f,g$ in clear and verifier has commitments to $f,g$.</li>
</ul>
<ol>
<li><p>Verifier samples a random $r$.</p>
</li>
<li><p>Prover constructs $\hat{f}$ using the evaluations of $f$, so is $\hat{g}$.</p>
</li>
<li><p>Then prover wants to prove $\hat{f}(r)=\hat{g}(r)$.</p>
<ol>
<li><p>It can be transformed to prove $\frac{\hat{f}(r)}{\hat{g}(r)}=1$ where $r$ is <u>fixed</u>.</p>
</li>
<li><p>They can <strong>perform prod-check</strong> to prove </p>
<p> $$<br> \frac{\hat{f}(r)}{\hat{g}(r)}=\prod_{a\in \Omega}\left(\frac{r-f(a)}{r-g(a)}\right)=1<br> $$</p>
<p> where the <u>rational function</u> is defined as $\frac{r-f(X)}{r-g(X)}$ on $\Omega$.</p>
</li>
</ol>
</li>
</ol>
<ul>
<li><u>Proof size:</u> two commits and six evaluations, same as prod-check on rational functions.</li>
</ul>
<p>It’s a public-coin protocol that can be rendered non-interactive.</p>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>This protocol is complete and sound assuming $2d/p$ is negligible.</p>
<h2 id="Prescribed-Permutation-Check"><a href="#Prescribed-Permutation-Check" class="headerlink" title="Prescribed Permutation Check"></a>Prescribed Permutation Check</h2><p>Let’s look into an embellished permutation check where the <u>permutation is prescribed by a specific permutation $W$.</u></p>
<p>We say $W:\Omega\rightarrow \Omega$ is a permutation of $\Omega$ if $\forall i\in [k]$: $W(\omega^i)=\omega^j$ is <u>bijection</u>.</p>
 <article class="message message-immersive is-primary"> <div class="message-body"> <i class="fas fa-info-circle mr-2"></i>  

<p>A bijection means <strong>one-to-one correspondence.</strong></p>
<p>A bijection function is <strong>injective and surjective.</strong></p>
 </div> </article> 



<p>Let $f,g$ be polynomials in $\mathbb{F}_p^{(\le d)}[X]$.</p>
<p>Verifier has three individual commitments to $f, g,$ and $W$.</p>
<p>In prescribed permutation check, the <strong>goal</strong> of prover is to prove that $f(y)=g(W(y))$ for all $y\in \Omega$.</p>
<p>In other works, it proves <u>that $g(\Omega)$ is the same as $f(\Omega)$, permuted by the prescribed $W$.</u></p>
<hr>
<p>At first sight, we try to use a zero-test to prove $f(y)-g(W(y))=0$ on $\Omega$.</p>
<p>But the <strong>problem</strong> is the <u>polynomial $f(y)-g(W(y))$ has degree $k^2$</u> since $g(W(y))$ is a composition of $f$ and $W$.</p>
<p>Then prover would need to manipulate polynomials of degree $k^2$, <u>resulting a quadratic time prover !!</u> </p>
<p>Yet we want <strong>a linear time prover.</strong></p>
<hr>
<p>Let’s reduce this to a <strong>prod-check</strong> <u>on a polynomial of degree $2k$.</u></p>
<p><font color=blue><u><b>Observation:</b></u></font> </p>
<p>If $(W(a),f(a))_{a\in \Omega}$ is a permutation of $(a, g(a))_{a\in \Omega}$,</p>
<p>then $f(y)=g(W(y))$ for all $y\in \Omega$.</p>
<p>By the definition of permutation, for $a\in \Omega$, there exists a $a’\in \Omega$ $W(a’)=a$ and $f(a’)=g(a)$ hold. Then we have $f(a’)=g(W(a’))$.</p>
<p>The following example illustrates the proof.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZJ1A.png" alt="proof by an example" style="zoom:43%;" />



<p>Likewise, we construct auxiliary polynomials that have the <u>evaluations as its root yet the evaluations are listed in form of the tuple.</u></p>
<p>The <strong>intuition</strong> is to <u>encode the tuple to a variable</u>, then use a similar way to <u>construct a bivariate polynomial that has the variables as its root.</u></p>
<p>Hence, the tuple is encoded as variables $Y\cdot W(a)+f(a)$ and $Y\cdot a+g(a)$, respectively.</p>
<p>And the <u>bivariate polynomials</u> of total degree $k$ is constructed as follows.</p>

$$
\begin{cases} \hat{f}(X,Y)&= \prod _{a\in \Omega}(X-Y\cdot W(a)-f(a)) \\ \hat{g}(X,Y) &= \prod_{a\in \Omega}(X-Y\cdot a -g(a))\end{cases}
$$



<p>The following lemma shows the correctness.</p>
<p><font color=blue><u><b>Lemma:</b></u></font> </p>


$\hat{f}(X,Y)=\hat{g}(X,Y)$ if and only if $(W(a),f(a))_{a\in \Omega}$ is a permutation of $(a,g(a))_{a\in \Omega}$.



<p>To prove, use the fact that $\mathbb{F}_p[X,Y]$ is a unique factorization domain. Yet I’m not familiar with this fact.</p>
<p>The complete protocol is depicted as follows, which <strong>composes a prod-check on the rational function</strong> $\frac{r-s\cdot W(X)-f(X)}{r-s\cdot X-g(X)}$ where $r,s$ are fixed and randomly chosen by the verifier.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCb11tx.png" alt="Complete protocol for prescribed permutation check" style="zoom:33%;" />



<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>This protocol is complete and sound assuming $2d/p$ is negligible.</p>
<h1 id="The-PLONK-IOP-for-General-Circuits"><a href="#The-PLONK-IOP-for-General-Circuits" class="headerlink" title="The PLONK IOP for General Circuits"></a>The PLONK IOP for General Circuits</h1><p><a href="eprint/2019/953">PLONK</a></p>
<p>Finally, let’s introduce PLONK IOP, a widely used proof system in practice.</p>
<p>It is a poly-IOP for a general circuit $C(x,w)$.</p>
<p>We can think the <strong>PLONK IOP</strong> as <u>an abstract IOP that can be combined with different polynomial commitment schemes to construct actual SNARK system.</u></p>
<img src="https://s1.ax1x.com/2023/07/21/pCb1lA1.png" alt="PLONK IOP " style="zoom:33%;" />



<h2 id="Step1-compile-circuit-to-a-computation-trace"><a href="#Step1-compile-circuit-to-a-computation-trace" class="headerlink" title="Step1: compile circuit to a computation trace"></a>Step1: compile circuit to a computation trace</h2><p>The first step is to <u>compile a general circuit to a computation trace</u> that can <u>be encoded by a polynomial.</u></p>
<p>Considering a general circuit $(x_1+x_2)(x_2+w_1)$ with two public inputs and one witness input, we can write the computation trace into a table as follows. This compilation is also called <strong>arithmetization</strong>.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCb1M7R.png" alt="arithmetization: compile the circuit to a computation trace" style="zoom:33%;" />



<p>The example is illustrated as above.</p>
<p>Let $|C|$  denote the total # of gates in $C$. </p>
<p>Let $|I|=|I_x|+|I_w|$ denote the # inputs to $C$. </p>
  Let $d=3|C|+|I|$ and $\Omega=\{1,\omega, \omega^2, \dots, \omega^{d-1}\}$ where  $\omega\in \mathbb{F}_p$ is the primitive $k$-th root of unity so that $\omega ^d=1$.  

<p>In the above example, $|C|=3$, $|I|=3$, and $d=12$.</p>
<p>The <strong>plan</strong> is <u>prover can interpolates a polynomial $T\in \mathbb{F}_p^{(\le d)}[X]$ that encodes the entire trace.</u></p>
<ol>
<li>$T$ <strong>encodes all inputs</strong>:   $T(\omega^{-j})=\text{input }\# j \text{ for } j=1,\dots, |I|$. </li>
<li>$T$ <strong>encodes all wires</strong>: $\forall l=0,\dots, |C|-1$:<br>For each gate labeled by $l$,<ol>
<li>$T(\omega^{3l})$: left input to gate  $\#l$  </li>
<li>$T(\omega^{3l+1})$: right input to gate  $\#l$  </li>
<li>$T(\omega^{3l+2})$: output to gate  $\#l$  </li>
</ol>
</li>
</ol>
<p>In our example, prover interpolates $T(X)$ of degree 11 such that:</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZd78.png" alt="interpolate T with 12 points" style="zoom:33%;" />



<p>Note that prover can use FFT / NTT to compute the coefficients of $T$ in time $O(d\log d)$.</p>
<h2 id="Step2-proving-validity-of-T"><a href="#Step2-proving-validity-of-T" class="headerlink" title="Step2: proving validity of $T$"></a>Step2: proving validity of $T$</h2><p>Then prover <u>commits to the polynomial</u> $T$ encoded by the computation trace, and <u>needs to prove that $T$ is a correct computation trace.</u></p>
<img src="https://s1.ax1x.com/2023/07/21/pCbZa0f.png" alt="commits to T" style="zoom:33%;" />



<p><font color=blue><u><b>Proving Validity of :</b></u></font> </p>
<ol>
<li>$T$ encodes the correct <u>inputs</u>.</li>
<li>Every <u>gate</u> is evaluated correctly.</li>
<li>The <u>wiring</u> is implemented correctly.</li>
<li>The <u>output</u> of last gates is 0.<br>(In our example, the output is 77)</li>
</ol>
<p><u>Proving (4)</u> is easy that only proves $T(\omega^{3|C|-1})=0$.</p>
<p>The <u>wiring constraints</u> contains that the second input $6$ is connected with the left wire of the gate 0 and the right wire of the gate 1 as depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCblQW8.png" alt="wiring constraints" style="zoom:33%;" />



<h3 id="1-T-encodes-the-correct-input"><a href="#1-T-encodes-the-correct-input" class="headerlink" title="(1) $T$ encodes the correct input"></a>(1) $T$ encodes the correct input</h3><p>Note that the statement $x$ is public.</p>
<p>Both <u>prover and verifier</u> interpolate a polynomial $v(X)\in \mathbb{F}_p^{(\le |I_x|)}[X]$ that encodes the $x$-inputs to the circuit:</p>

$$
\text{for }j=1,\dots, |I_x|: v(\omega^{-j})=\text{input }\# j
$$



<p>In our example, $v(\omega^{-1})=5,v(\omega^{-2})=6$, hence $v$ is linear.</p>
<p>Note that constructing $v(X)$ takes time proportional to the size of input $x$ so that verifier has time to do this.</p>
  Let $\Omega_{\text{inp}}=\{\omega^{-1},\omega^{-2},\dots, \omega^{-|I_x|}\}\subseteq \Omega$ that <u>contains the points encoding the inputs.</u>  

<p>Prover proves (1) by using <strong>ZeroTest</strong> on $\Omega_{\text{inp}}$ to prove that </p>
<p>$$<br>T(y)-v(y)=0 ; \forall y\in \Omega_{\text{inp}}<br>$$</p>
<p>Note that verifier can  construct $v(X)$ explicitly so verifier only query $T(X)$ at randomly chosen $r$.</p>
<h3 id="2-every-gate-is-evaluated-correctly"><a href="#2-every-gate-is-evaluated-correctly" class="headerlink" title="(2) every gate is evaluated correctly"></a>(2) every gate is evaluated correctly</h3><p>Suppose that the circuit only composes the additional gates and multiplication gates.</p>
<p>The <strong>idea of differentiating</strong> is to <u>encode gate types using a selector polynomial $S(X)$.</u></p>
<p>Define $S(X)\in\mathbb{F}_p^{(\le d)}[X]$ such that $\forall l=0, \dots, |C|-1$:</p>

$$
\begin{cases}S(\omega^{3l})&= 1 \text{ if gate }\# l \text{ is an addition gate} \\ S(w^{3l})&=0\text{ if gate }\# l \text{ is an multiplication gate}\end{cases}
$$



<p>In our example, the selector polynomial is interpolated as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbl1SS.png" alt="Interpolation for selector polynomial S(X)" style="zoom:33%;" />



<p>The selector polynomial will be <strong>committed in the preprocessing phase</strong> because it is <u>a function of the circuit,</u> which just encodes what the gates represent in the circuit.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCblMJf.png" alt="S can be preprocessed in the setup" style="zoom:33%;" />



<p>With the selector polynomial, we can <u>encode the addition gates and the multiplication gates into a single polynomial.</u></p>
  
$$
\forall y\in \Omega_{\text{gates}}=\{1,\omega^3,\omega^6,\omega^9,\dots, \omega^{3(|C|-1)}\}: \\ S(y)\cdot [T(y) + T(\omega y)] + (1-S(y))\cdot T(y)\cdot T(\omega y)=T(\omega^2 y)
$$

  

<p>If the above equality holds, it means that all the addition gates and multiplication gates are evaluated correctly.</p>
<ul>
<li> $\#l$ is an **addition gate** → $S(y=\omega^{3l})=1$
<ul>
<li>Prove that the sum of the left input and right input equals to the output, i.e. $T(y)+T(\omega y)=T(\omega^2 y)$.</li>
</ul>
</li>
<li> $\#l$  is a **multiplication gate** → $S(y=\omega^{3l})=0$
<ul>
<li>Prove that the product of the left input and right input equals to the output, i.e. $T(y)\cdot T(\omega y)=T(\omega^2 y)$.</li>
</ul>
</li>
</ul>
<p>Then prover uses ZeroTest to prove that for $\forall y\in \Omega_{\text{gates}}$:</p>
<p>$$<br>S(y)\cdot [T(y) + T(\omega y)] + (1-S(y))\cdot T(y)\cdot T(\omega y)-T(\omega^2 y)=0<br>$$</p>
<h3 id="3-the-wiring-is-correct"><a href="#3-the-wiring-is-correct" class="headerlink" title="(3) the wiring is correct"></a>(3) the wiring is correct</h3><p>The last thing is to prove the wiring is correct.</p>
<p>First we  <strong>construct the wiring constraints</strong> to <u>encode the wires of $C$.</u></p>
<p>In our example, the(incomplete) wiring constraints are listed as follows. The first constraint means that the second input is connected to the right input of the gate 0 and the left input of the gate 1.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbl8yQ.png" alt="wiring constraints" style="zoom:33%;" />



<p>Then <u>define a polynomial $W:\Omega\rightarrow \Omega$ that implements a rotation:</u></p>
<ul>
<li>$W(\omega^{-2},\omega^{1},\omega^3)=(\omega^{1},\omega^3,\omega^{-2})$</li>
<li>$W(\omega^{-1},\omega^0)=(\omega^{0},\omega^{-1})$</li>
<li>… …</li>
</ul>
<p>The rotation means $W$ maps  $\omega^{-2}$ → $\omega^{1}$, $w^1$ → $\omega^3$, and  $\omega^3$→ $\omega^{-2}$.</p>
<p>It means the polynomial $T$ is invariant under this rotation.</p>
<p>Note that $W$ actually defines a <u>prescribed permutation.</u></p>
<p>Finally, the following lemma tells us we can prove the wiring constraints <strong>using a prescribed permutation check</strong>.</p>
<p><font color=blue><u><b>Lemma:</b></u></font> </p>
<p>$\forall y\in \Omega$: if $T(y)=T(W(y))$, then wire constraints are satisfied.</p>
<p>It’s a clever way of encoding all the wiring constraints.</p>
<p>Note that the polynomial $W$ doesn’t depend on the inputs so it represents <u>an intrinsic property of the circuit itself</u>, which can be committed in the setup.</p>
<h2 id="Complete-Plonk-Poly-IOP"><a href="#Complete-Plonk-Poly-IOP" class="headerlink" title="Complete Plonk Poly-IOP"></a>Complete Plonk Poly-IOP</h2><p>The complete Plonk poly-IOP (and SNARK) is depicted as follows.</p>
<img src="https://s1.ax1x.com/2023/07/21/pCbl3Qg.png" alt="PLONK Poly-IOP" style="zoom:33%;" />



<p>Let’s elaborate on the details.</p>
<ul>
<li>The setup preprocesses the circuit $C$ and outputs the commitmens to the <u>selector polynomial $S$ and the wiring polynomial $W$.</u> It is <strong>untrusted</strong> that anyone can check these commitments were done correctly.</li>
<li>Prover compiles the circuit to a computation trace, and encodes the entire trace into a polynomial $T(X)$.</li>
<li>Verifier can construct $v(X)$ explicitly from the public inputs $x$.</li>
<li>Then prover proves validity of $T$:<ul>
<li>gates: evaluated correctly by <strong>ZeroTest</strong></li>
<li>inputs: correct inputs by <strong>ZeroTest</strong></li>
<li>wires: correct wirings by <strong>Prescribed Permutation Check</strong></li>
<li>output: correct output by <strong>evaluation proof</strong></li>
</ul>
</li>
</ul>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>The Plonk Poly-IOP is complete and knowledge sound, assuming $7|C|/p$ is negligible.</p>
<ul>
<li>$7|C|$ bounds the degree of the polynomial of $S\cdot T \cdot T$.</li>
<li>constant proof size: a short proof with $O(1)$ commitments.</li>
<li>fast verifier: runs in logarithmic time $O(\log |C|)$</li>
<li>quasi-linear prover: $O(|C|\log |C|)$</li>
<li>SNARK: rendered via Fiat-Shamir Transform</li>
</ul>
<p>Note that the SNARK is <u>not necessarily zk</u> since the commitments are not zk and the openings are not as well.</p>
<p>But there are generic transformations that can efficiently convert any Poly-IOP into a zk Poly-IOP, rendering a zk-SNARK.</p>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><h3 id="Hyperplonk-linear-prover"><a href="#Hyperplonk-linear-prover" class="headerlink" title="Hyperplonk: linear prover"></a>Hyperplonk: linear prover</h3><p>The main challenge in PLONK is the prover runs in quasi-linear time.</p>
<p>Hyperplonk replaces $\Omega$ with ${0,1}^t$ where $t=\log _2 |\Omega|$ to achieve a linear prover.</p>
<p>The polynomial $T$ is now <u>a multilinear polynomial in $t$ variables</u>, and the computation trace is encoded on the vertices of the $t$-dim hypercube.</p>
<p>ZeroTest is replaced by a multilinear SumCheck.</p>
<p>Recall that the prover time in SumCheck (<a href="/2023/07/18/zkp-lec4/" title="[Lecture 4]">[Lecture 4]</a>) has a factor $2^t$, which is <u>linear</u> to $|C|$.</p>
<p>It turns out that all tools to build for <u>proving facts about committed univariate polynomials can be generalized to work and prove properties of multilinear polynomials.</u></p>
<h3 id="Plonkish-Arithmetization"><a href="#Plonkish-Arithmetization" class="headerlink" title="Plonkish Arithmetization"></a>Plonkish Arithmetization</h3><p>Another extension is about the arithmetization, including the <strong>custom gates</strong> and <strong>Plookup.</strong></p>
<p>Having these extension allows to <u>shrink the size of the computation traces, which speed up the prover runtime.</u></p>
<p>It supports custom gates other than addition gates and multiplication gates.</p>
<p>The plonkish computation trace can be illustrated as follows:</p>
<img src="https://s1.ax1x.com/2023/07/21/pCblGLj.png" alt="plonkish computation trace" style="zoom:33%;" />

<p>It is defined by a <strong>custom gate</strong> that computes $v_4+w_3\cdot t_3$ and outputs $t_4$.</p>
<p>Likewise, we can encode it into the following polynomial</p>
<p>$$<br>\forall y\in \Omega_{\text{gates}}: v(y\omega)+w(y)\cdot t(y)-t(y\omega)=0<br>$$</p>
<p>Prover uses a ZeroTest check to prove that <u>the custom gate is evaluated correctly.</u></p>
<p>All such gate checks are included in the gate check <u>by multiplying a selector polynomial.</u></p>
<p>Furthermore, <strong>Plookup</strong> can <u>ensure some values in the computation trace are in pre-defined list.</u></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>「Cryptography-ZKP」: Lec5-The Plonk SNARK</p><p><a href="https://f7ed.com/2023/07/21/zkp-lec5/">https://f7ed.com/2023/07/21/zkp-lec5/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>f7ed</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-07-21</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-08-15</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Cryptography/">Cryptography, </a><a class="link-muted" rel="tag" href="/tags/ZKP/">ZKP, </a><a class="link-muted" rel="tag" href="/tags/SNARKs/">SNARKs, </a><a class="link-muted" rel="tag" href="/tags/KZG/">KZG, </a><a class="link-muted" rel="tag" href="/tags/Plonk/">Plonk </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/qrcode_wechat.jpg" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/f7ed" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/qrcode_alipay.jpg" alt="Alipay"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/07/26/zkp-lec6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「Cryptography-ZKP」: Lec6 Poly-commit based on Pairing and Discret-log</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/18/zkp-lec4/"><span class="level-item">「Cryptography-ZKP」: Lec4-SNARKs via IP</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "8613f5a01abf84bc76a00bf20c78d324",
            repo: "f7ed.github.io",
            owner: "f7ed",
            clientID: "ec59f5258ac0ec443907",
            clientSecret: "f092b308c3e1b46327481c3547ee0dd7fc1bda10",
            admin: ["f7ed"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/profile.png" alt="f7ed"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">f7ed</p><p class="is-size-6 is-block">热爱可抵漫长岁月。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">70</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">135</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:f7edliu@outlook.com" target="_blank" rel="noopener">Email me</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#What-is-SNARK"><span class="level-left"><span class="level-item">1</span><span class="level-item">What is SNARK?</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#preprocessing-NARK"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">preprocessing NARK</span></span></a></li><li><a class="level is-mobile" href="#SNARK-a-Succinct-ARgument-of-Knowledge"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">SNARK: a Succinct ARgument of Knowledge</span></span></a></li><li><a class="level is-mobile" href="#Types-of-preprocessing-Setup"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Types of preprocessing Setup</span></span></a></li></ul></li><li><a class="level is-mobile" href="#General-Paradigm-for-Building-SNARK"><span class="level-left"><span class="level-item">2</span><span class="level-item">General Paradigm for Building SNARK</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Polynomial-Commitments"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Polynomial Commitments</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Equality-Test-Protocol"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Equality Test Protocol</span></span></a></li><li><a class="level is-mobile" href="#Fiat-Shamir-Transform"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">Fiat-Shamir Transform</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mathcal-F-IOP"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">$\mathcal{F}$-IOP</span></span></a></li></ul></li><li><a class="level is-mobile" href="#KZG-Poly-Commit-Scheme"><span class="level-left"><span class="level-item">3</span><span class="level-item">KZG Poly-Commit Scheme</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#KZG-A-Binding-PSC"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">KZG: A Binding PSC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Commitment"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">Commitment</span></span></a></li><li><a class="level is-mobile" href="#Evaluation"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">Evaluation</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Generalizations"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Generalizations</span></span></a></li><li><a class="level is-mobile" href="#Properties-linear-time-commitment"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Properties: linear time commitment</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Multi-point-Proof-Generation"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">Multi-point Proof Generation</span></span></a></li><li><a class="level is-mobile" href="#The-Dory-polynomial-commitment"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">The Dory polynomial commitment</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Applications-vector-commitment"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Applications: vector commitment</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Proving-properties-of-committed-polynomials"><span class="level-left"><span class="level-item">4</span><span class="level-item">Proving properties of committed polynomials</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Polynomial-Equality-Testing-with-KZG"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Polynomial Equality Testing with KZG</span></span></a></li><li><a class="level is-mobile" href="#Summary-of-Proof-Gadgets-for-Univariates"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Summary of Proof Gadgets for Univariates</span></span></a></li><li><a class="level is-mobile" href="#Vanishing-Polynomial"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Vanishing Polynomial</span></span></a></li><li><a class="level is-mobile" href="#ZeroTest-on-Omega"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">ZeroTest on $\Omega$</span></span></a></li><li><a class="level is-mobile" href="#Product-Check-on-Omega"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">Product Check on $\Omega$</span></span></a></li><li><a class="level is-mobile" href="#Permutation-Check"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">Permutation Check</span></span></a></li><li><a class="level is-mobile" href="#Prescribed-Permutation-Check"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">Prescribed Permutation Check</span></span></a></li></ul></li><li><a class="level is-mobile" href="#The-PLONK-IOP-for-General-Circuits"><span class="level-left"><span class="level-item">5</span><span class="level-item">The PLONK IOP for General Circuits</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Step1-compile-circuit-to-a-computation-trace"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Step1: compile circuit to a computation trace</span></span></a></li><li><a class="level is-mobile" href="#Step2-proving-validity-of-T"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Step2: proving validity of $T$</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-T-encodes-the-correct-input"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">(1) $T$ encodes the correct input</span></span></a></li><li><a class="level is-mobile" href="#2-every-gate-is-evaluated-correctly"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">(2) every gate is evaluated correctly</span></span></a></li><li><a class="level is-mobile" href="#3-the-wiring-is-correct"><span class="level-left"><span class="level-item">5.2.3</span><span class="level-item">(3) the wiring is correct</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Complete-Plonk-Poly-IOP"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">Complete Plonk Poly-IOP</span></span></a></li><li><a class="level is-mobile" href="#Extensions"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Extensions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Hyperplonk-linear-prover"><span class="level-left"><span class="level-item">5.4.1</span><span class="level-item">Hyperplonk: linear prover</span></span></a></li><li><a class="level is-mobile" href="#Plonkish-Arithmetization"><span class="level-left"><span class="level-item">5.4.2</span><span class="level-item">Plonkish Arithmetization</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 f7ed</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="f7ed&#039;s GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script>
      var sc_project=12961083;
      var sc_invisible=1;
      var sc_security="ad3fb575";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12961083/0/ad3fb575/1/" alt="real time web analytics"></div></noscript><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>