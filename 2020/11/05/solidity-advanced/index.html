<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「区块链」：Solidity-advanced - fred&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fred&#039;s blog"><meta name="msapplication-TileImage" content="/img/heart.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fred&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Solidity的官方教程笔记：advanced。"><meta property="og:type" content="blog"><meta property="og:title" content="「区块链」：Solidity-advanced"><meta property="og:url" content="https://f7ed.com/2020/11/05/solidity-advanced/"><meta property="og:site_name" content="fred&#039;s blog"><meta property="og:description" content="Solidity的官方教程笔记：advanced。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://f7ed.com/gallery/thumbnails/ethereum-VM-solidity.png"><meta property="article:published_time" content="2020-11-04T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-22T02:30:52.874Z"><meta property="article:author" content="f7ed"><meta property="article:tag" content="blockchain"><meta property="article:tag" content="solidity"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/thumbnails/ethereum-VM-solidity.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://f7ed.com/2020/11/05/solidity-advanced/"},"headline":"「区块链」：Solidity-advanced","image":["https://f7ed.com/gallery/thumbnails/ethereum-VM-solidity.png"],"datePublished":"2020-11-04T16:00:00.000Z","dateModified":"2021-05-22T02:30:52.874Z","author":{"@type":"Person","name":"f7ed"},"publisher":{"@type":"Organization","name":"fred's blog","logo":{"@type":"ImageObject","url":"https://f7ed.com/img/f1ed_logo.png"}},"description":"Solidity的官方教程笔记：advanced。"}</script><link rel="canonical" href="https://f7ed.com/2020/11/05/solidity-advanced/"><link rel="icon" href="/img/heart.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-M5KG3CQTSF" async></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-M5KG3CQTSF');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="fred's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/liu">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-bars"></i>「区块链」：Solidity-advanced</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2020-11-04T16:00:00.000Z" title="2020-11-04T16:00:00.000Z">2020-11-05</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-05-22T02:30:52.874Z" title="2021-05-22T02:30:52.874Z">2021-05-22</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span><span class="level-item"><i class="far fa-clock"></i> an hour read (About 11285 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>Solidity的<a target="_blank" rel="noopener" href="https://cryptozombies.io/zh/course">官方教程</a>笔记：advanced。 </p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="more"></span>

<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="第1章-智能协议的永固性"><a href="#第1章-智能协议的永固性" class="headerlink" title="第1章: 智能协议的永固性"></a>第1章: 智能协议的永固性</h2><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p>
<p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p>
<p>第一个例子，在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p>
<p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p>
<p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p>
<h3 id="外部依赖关系"><a href="#外部依赖关系" class="headerlink" title="外部依赖关系"></a>外部依赖关系</h3><p>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p>
<p>我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p>
<p>我们不再一开始就把猎物地址给写入代码，而是写个函数 <code>setKittyContractAddress</code>, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p>
<h2 id="第2章-Ownable-Contracts"><a href="#第2章-Ownable-Contracts" class="headerlink" title="第2章: Ownable Contracts"></a>第2章: Ownable Contracts</h2><h3 id="OpenZeppelin库的Ownable-合约"><a href="#OpenZeppelin库的Ownable-合约" class="headerlink" title="OpenZeppelin库的Ownable 合约"></a>OpenZeppelin库的<code>Ownable</code> 合约</h3><p>OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> <span class="variable">Ownable</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev</span> The Ownable contract has an owner address, and provides basic authorization control</span></span><br><span class="line"><span class="comment"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract <span class="title class_">Ownable</span> &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event <span class="title class_">OwnershipTransferred</span>(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev</span> The Ownable constructor sets the original `owner` of the contract to the sender</span></span><br><span class="line"><span class="comment">   * account.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Ownable</span>(<span class="params"></span>) public &#123;</span><br><span class="line">    owner = msg.<span class="property">sender</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev</span> Throws if called by any account other than the owner.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  modifier <span class="title function_">onlyOwner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.<span class="property">sender</span> == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev</span> Allows the current owner to transfer control of the contract to a newOwner.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newOwner The address to transfer ownership to.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">transferOwnership</span>(<span class="params">address newOwner</span>) public onlyOwner &#123;</span><br><span class="line">    <span class="built_in">require</span>(newOwner != <span class="title function_">address</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="title class_">OwnershipTransferred</span>(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面有没有您没学过的东东？</p>
<ul>
<li>构造函数：<code>function Ownable()</code>是一个 <strong>constructor</strong> (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li>
<li>函数修饰符：<code>modifier onlyOwner()</code>。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 <code>onlyOwner</code> 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的<code>_;</code>。</li>
<li><code>indexed</code> 关键字：别担心，我们还用不到它。</li>
</ul>
<p>所以<code>Ownable</code> 合约基本都会这么干：</p>
<ol>
<li>合约创建，构造函数先行，将其 <code>owner</code> 设置为<code>msg.sender</code>（其部署者）</li>
<li>为它加上一个修饰符 <code>onlyOwner</code>，它会限制陌生人的访问，将访问某些函数的权限锁定在 <code>owner</code> 上。</li>
<li>允许将合约所有权转让给他人。</li>
</ol>
<p><code>onlyOwner</code> 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制/粘贴 <code>Ownable</code> 开始的，从它再继承出的子类，并在之上进行功能开发。</p>
<p>既然我们想把 <code>setKittyContractAddress</code> 限制为 <code>onlyOwner</code> ，我们也要做同样的事情。</p>
<h2 id="第3章-onlyOwner-函数修饰符"><a href="#第3章-onlyOwner-函数修饰符" class="headerlink" title="第3章: onlyOwner 函数修饰符"></a>第3章: onlyOwner 函数修饰符</h2><p>现在我们有了个基本版的合约 <code>ZombieFactory</code> 了，它继承自 <code>Ownable</code> 接口，我们也可以给 <code>ZombieFeeding</code> 加上 <code>onlyOwner</code> 函数修饰符。</p>
<p>ZombieFeeding 是个 ZombieFactory </p>
<p>ZombieFactory 是个 Ownable</p>
<p>因此 <code>ZombieFeeding</code> 也是个 <code>Ownable</code>, 并可以通过 <code>Ownable</code> 接口访问父类中的函数/事件/修饰符。往后，<code>ZombieFeeding</code> 的继承者合约们同样也可以这么延续下去。</p>
<h3 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h3><p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p>
<p>咱们仔细读读 <code>onlyOwner</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev</span> 调用者不是‘主人’，就会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">modifier <span class="title function_">onlyOwner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(msg.<span class="property">sender</span> == owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onlyOwner</code> 函数修饰符是这么用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">MyContract</span> is <span class="title class_">Ownable</span> &#123;</span><br><span class="line">  event <span class="title class_">LaughManiacally</span>(string laughter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意！ `onlyOwner`上场 :</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">likeABoss</span>(<span class="params"></span>) external onlyOwner &#123;</span><br><span class="line">    <span class="title class_">LaughManiacally</span>(<span class="string">&quot;Muahahahaha&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时：</p>
<ol>
<li><strong>首先执行</strong> <code>onlyOwner</code> 中的代码。</li>
<li>执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</li>
</ol>
<p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p>
<p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p>
<blockquote>
<p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p>
</blockquote>
<blockquote>
<p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
</blockquote>
<h2 id="第4章-Gas"><a href="#第4章-Gas" class="headerlink" title="第4章: Gas"></a>第4章: Gas</h2><p>现在我们懂了如何在禁止第三方修改我们的合约的同时，留个后门给咱们自己去修改。</p>
<p>让我们来看另一种使得 Solidity 编程语言与众不同的特征：</p>
<h3 id="Gas-驱动以太坊DApps的能源"><a href="#Gas-驱动以太坊DApps的能源" class="headerlink" title="Gas - 驱动以太坊DApps的能源"></a>Gas - 驱动以太坊DApps的能源</h3><p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 <strong>gas</strong>，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p>
<p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 <strong>gas</strong> 等于这个操作背后的所有运算花销的总和。</p>
<p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。</p>
<h3 id="为什么要用-gas-来驱动？"><a href="#为什么要用-gas-来驱动？" class="headerlink" title="为什么要用 gas 来驱动？"></a>为什么要用 gas 来驱动？</h3><p>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p>
<p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p>
<blockquote>
<p><em>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</em></p>
</blockquote>
<h3 id="省-gas-的招数：结构封装-（Struct-packing）"><a href="#省-gas-的招数：结构封装-（Struct-packing）" class="headerlink" title="省 gas 的招数：结构封装 （Struct packing）"></a>省 gas 的招数：结构封装 （Struct packing）</h3><p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p>
<p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p>
<p>除非，把 <code>uint</code> 绑定到 <code>struct</code> 里面。</p>
<p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="title class_">NormalStruct</span> &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">MiniMe</span> &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span></span><br><span class="line"><span class="title class_">NormalStruct</span> normal = <span class="title class_">NormalStruct</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="title class_">MiniMe</span> mini = <span class="title class_">MiniMe</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); </span><br></pre></td></tr></table></figure>

<p>所以，当 <code>uint</code> 定义在一个 <code>struct</code> 中的时候，尽量使用最小的整数子类型以节约空间。 并且把同样类型的变量放一起（即在 struct 中将把变量按照类型依次放置），这样 Solidity 可以将存储空间最小化。例如，有两个 <code>struct</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint</span> c; <span class="type">uint32</span> a; <span class="type">uint32</span> b;<span class="string">` 和 `</span><span class="type">uint32</span> a; <span class="type">uint</span> c; <span class="type">uint32</span> b;</span><br></pre></td></tr></table></figure>

<p>前者比后者需要的gas更少，因为前者把<code>uint32</code>放一起了。</p>
<h2 id="第5章-时间单位"><a href="#第5章-时间单位" class="headerlink" title="第5章: 时间单位"></a>第5章: 时间单位</h2><p><code>level</code> 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p>
<p><code>readyTime</code> 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p>
<p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。</p>
<h3 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h3><p>Solidity 使用自己的本地时间单位。</p>
<p>变量now:</p>
<p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1604319686</code>。</p>
<blockquote>
<p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
</blockquote>
<p>时间单位：seconds minutes hours days weeks years</p>
<p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将‘上次更新时间’ 设置为 ‘现在’</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateTimestamp</span>(<span class="params"></span>) public &#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果到上次`updateTimestamp` 超过5分钟，返回 &#x27;true&#x27;</span></span><br><span class="line"><span class="comment">// 不到5分钟返回 &#x27;false&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fiveMinutesHavePassed</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (bool) &#123;</span><br><span class="line">  <span class="keyword">return</span> (now &gt;= (lastUpdated + <span class="number">5</span> minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。</p>
<h2 id="第6章-僵尸冷却"><a href="#第6章-僵尸冷却" class="headerlink" title="第6章: 僵尸冷却"></a>第6章: 僵尸冷却</h2><p>首先，我们要定义一些辅助函数，设置并检查僵尸的 <code>readyTime</code>。</p>
<h3 id="将结构体作为参数传入"><a href="#将结构体作为参数传入" class="headerlink" title="将结构体作为参数传入"></a>将结构体作为参数传入</h3><p>由于结构体的存储指针可以以参数的方式传递给一个 <code>private</code> 或 <code>internal</code> 的函数，因此结构体可以在多个函数之间相互传递。</p>
<p>把结构体作为指针，因此传递参数前需要加<code>storage</code> </p>
<p>遵循这样的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_doStuff</span>(<span class="params">Zombie storage _zombie</span>) internal &#123;</span><br><span class="line">  <span class="comment">// do stuff with _zombie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。</p>
<h2 id="第7章-公有函数和安全性"><a href="#第7章-公有函数和安全性" class="headerlink" title="第7章: 公有函数和安全性"></a>第7章: 公有函数和安全性</h2><p>你必须仔细地检查所有声明为 <code>public</code> 和 <code>external</code>的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 <code>onlyOwner</code> 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p>
<h2 id="第8章-进一步了解函数修饰符"><a href="#第8章-进一步了解函数修饰符" class="headerlink" title="第8章: 进一步了解函数修饰符"></a>第8章: 进一步了解函数修饰符</h2><p>我们打算让僵尸在达到一定水平后，获得特殊能力。但是达到这个小目标，我们还需要学一学什么是“函数修饰符”。</p>
<h3 id="带参数的函数修饰符"><a href="#带参数的函数修饰符" class="headerlink" title="带参数的函数修饰符"></a>带参数的函数修饰符</h3><p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储用户年龄的映射</span></span><br><span class="line">mapping (<span class="keyword">uint</span> =&gt; <span class="keyword">uint</span>) <span class="keyword">public</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定用户年龄的修饰符</span></span><br><span class="line">modifier olderThan(<span class="keyword">uint</span> _age, <span class="keyword">uint</span> _userId) &#123;</span><br><span class="line">  <span class="keyword">require</span>(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span></span><br><span class="line"><span class="comment">// 我们可以用如下参数调用`olderThan` 修饰符:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">driveCar</span><span class="params">(<span class="keyword">uint</span> _userId)</span> <span class="title">public</span> <span class="title">olderThan</span><span class="params">(<span class="number">16</span>, _userId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 其余的程序逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p>
<p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p>
<h3 id="带参数的函数修饰符-1"><a href="#带参数的函数修饰符-1" class="headerlink" title="带参数的函数修饰符"></a>带参数的函数修饰符</h3><p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储用户年龄的映射</span></span><br><span class="line"><span class="title function_">mapping</span> (<span class="function"><span class="params">uint</span> =&gt;</span> uint) public age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定用户年龄的修饰符</span></span><br><span class="line">modifier <span class="title function_">olderThan</span>(<span class="params">uint _age, uint _userId</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span></span><br><span class="line"><span class="comment">// 我们可以用如下参数调用`olderThan` 修饰符:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">driveCar</span>(<span class="params">uint _userId</span>) public <span class="title function_">olderThan</span>(<span class="params"><span class="number">16</span>, _userId</span>) &#123;</span><br><span class="line">  <span class="comment">// 其余的程序逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p>
<p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p>
<ol>
<li>记住，修饰符的最后一行为 <code>_;</code>，表示修饰符调用结束后返回，并执行调用函数余下的部分。</li>
</ol>
<h2 id="第10章-利用-‘View’-函数节省-Gas"><a href="#第10章-利用-‘View’-函数节省-Gas" class="headerlink" title="第10章: 利用 ‘View’ 函数节省 Gas"></a>第10章: 利用 ‘View’ 函数节省 Gas</h2><p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 <code>getZombiesByOwner</code>。</p>
<p>实现这个功能只需从区块链中读取数据，所以它可以是一个 <code>view</code> 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p>
<h3 id="“view”-函数不花-“gas”"><a href="#“view”-函数不花-“gas”" class="headerlink" title="“view” 函数不花 “gas”"></a>“view” 函数不花 “gas”</h3><p>当玩家从外部调用一个<code>view</code>函数，是不需要支付一分 gas 的。</p>
<p>这是因为 <code>view</code> 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 <code>view</code> 标记一个函数，意味着告诉 <code>web3.js</code>，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p>
<p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“<code>external view</code> 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p>
<blockquote>
<p><em>注意：如果一个</em> <code>view</code> <em>函数在另一个函数的内部被调用，而调用函数与</em> <code>view</code> <em>函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为</em> <code>view</code> <em>的函数只有在外部调用时才是免费的。</em></p>
</blockquote>
<h2 id="第11章-存储非常昂贵"><a href="#第11章-存储非常昂贵" class="headerlink" title="第11章: 存储非常昂贵"></a>第11章: 存储非常昂贵</h2><p>Solidity 使用<code>storage</code>(存储)是相当昂贵的，”写入“操作尤其贵。</p>
<p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p>
<p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 <code>memory</code>(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p>
<p>遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了<code>external view</code>的函数，遍历比 <code>storage</code> 要便宜太多，因为 <code>view</code> 函数不会产生任何花销。 （gas可是真金白银啊！）。</p>
<p>我们将在下一章讨论<code>for</code>循环，现在我们来看一下看如何如何在内存中声明数组。</p>
<h3 id="在内存中声明数组"><a href="#在内存中声明数组" class="headerlink" title="在内存中声明数组"></a>在内存中声明数组</h3><p>在数组后面加上 <code>memory</code>关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 <code>storage</code> 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在<code>view</code>里用，完全不用花钱。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArray</span>(<span class="params"></span>) external pure <span class="title function_">returns</span>(<span class="params">uint[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化一个长度为3的内存数组</span></span><br><span class="line">  uint[] memory values = <span class="keyword">new</span> uint[](<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  values.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">  values.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">  values.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 <code>for</code> 循环结合的做法。</p>
<blockquote>
<p>注意：内存数组 <strong>必须</strong> 用长度参数（在本例中为<code>3</code>）创建。目前不支持 <code>array.push()</code>之类的方法调整数组大小，在未来的版本可能会支持长度修改。</p>
</blockquote>
<h2 id="第12章-For-循环"><a href="#第12章-For-循环" class="headerlink" title="第12章: For 循环"></a>第12章: For 循环</h2><p>我们提到过，函数中使用的数组是运行时在内存中通过 <code>for</code> 循环实时构建，而不是预先建立在存储中的。</p>
<p>为什么要这样做呢？</p>
<p>为了实现 <code>getZombiesByOwner</code> 函数，一种“无脑式”的解决方案是在 <code>ZombieFactory</code> 中存入”主人“和”僵尸军团“的映射。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; <span class="keyword">uint</span>[]) <span class="keyword">public</span> ownerToZombies</span><br></pre></td></tr></table></figure>

<p>然后我们每次创建新僵尸时，执行 <code>ownerToZombies [owner] .push（zombieId）</code> 将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code> 函数也非常简单：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getZombiesByOwner</span>(address _owner) external view returns (uint[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ownerToZombies[_owner]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="这个做法有问题"><a href="#这个做法有问题" class="headerlink" title="这个做法有问题"></a>这个做法有问题</h3><p>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p>
<p>这个“换主”函数要做到：</p>
<p>1.将僵尸push到新主人的 <code>ownerToZombies</code> 数组中， 2.从旧主的 <code>ownerToZombies</code> 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p>
<p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p>
<p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p>
<blockquote>
<p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p>
</blockquote>
<p>由于从外部调用一个 <code>view</code> 函数是免费的，我们也可以在 <code>getZombiesByOwner</code> 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 <code>transfer</code> 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p>
<h3 id="使用-for-循环"><a href="#使用-for-循环" class="headerlink" title="使用 for 循环"></a>使用 <code>for</code> 循环</h3><p><code>for</code>循环的语法在 Solidity 和 JavaScript 中类似。</p>
<p>来看一个创建偶数数组的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEvens</span>(<span class="params"></span>) pure external <span class="title function_">returns</span>(<span class="params">uint[]</span>) &#123;</span><br><span class="line">  uint[] memory evens = <span class="keyword">new</span> uint[](<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// 在新数组中记录序列号</span></span><br><span class="line">  uint counter = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 在循环从1迭代到10：</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果 `i` 是偶数...</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 把它加入偶数数组</span></span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      <span class="comment">//索引加一， 指向下一个空的‘even’</span></span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将返回一个形为 <code>[2,4,6,8,10]</code> 的数组。</p>
<h1 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h1><h1 id="第1章-可支付"><a href="#第1章-可支付" class="headerlink" title="第1章: 可支付"></a>第1章: 可支付</h1><p>截至目前，我们只接触到很少的 <strong>函数修饰符</strong>。 要记住所有的东西很难，所以我们来个概览：</p>
<ol>
<li>我们有决定函数何时和被谁调用的可见性修饰符: <code>private</code> 意味着它只能被合约内部调用； <code>internal</code> 就像 <code>private</code> 但是也能被继承的合约调用； <code>external</code> 只能从合约外部调用；最后 <code>public</code> 可以在任何地方调用，不管是内部还是外部。</li>
<li>我们也有状态修饰符， 告诉我们函数如何和区块链交互: <code>view</code> 告诉我们运行这个函数不会更改和保存任何数据； <code>pure</code> 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</li>
<li>然后我们有了自定义的 <code>modifiers</code>，例如在第三课学习的: <code>onlyOwner</code> 和 <code>aboveLevel</code>。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</li>
</ol>
<p>这些修饰符可以同时作用于一个函数定义上：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> test() <span class="keyword">external</span> <span class="keyword">view</span> onlyOwner anotherModifier &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在这一章，我们来学习一个新的修饰符 <code>payable</code>.</p>
<h2 id="payable-修饰符"><a href="#payable-修饰符" class="headerlink" title="payable 修饰符"></a><code>payable</code> 修饰符</h2><p><code>payable</code> 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p>
<p>当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p>
<p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (<em>事务负载</em>)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 <strong>并</strong>付钱给另外一个合约。</p>
<p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">OnlineStore</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">buySomething</span>(<span class="params"></span>) external payable &#123;</span><br><span class="line">    <span class="comment">// 检查以确定0.001以太发送出去来运行函数:</span></span><br><span class="line">    <span class="built_in">require</span>(msg.<span class="property">value</span> == <span class="number">0.001</span> ether);</span><br><span class="line">    <span class="comment">// 如果为真，一些用来向函数调用者发送数字内容的逻辑</span></span><br><span class="line">    <span class="title function_">transferThing</span>(msg.<span class="property">sender</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>msg.value</code> 可以查看<code>msg.sender</code> 向合约发送了多少以太的方法，另外 <code>ether</code> 是一个内置单位。</p>
<p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span></span><br><span class="line"><span class="title class_">OnlineStore</span>.<span class="title function_">buySomething</span>().<span class="title function_">send</span>(<span class="attr">from</span>: web3.<span class="property">eth</span>.<span class="property">defaultAccount</span>, <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="number">0.001</span>))</span><br></pre></td></tr></table></figure>

<p>注意这个 <code>value</code> 字段， JavaScript 调用来指定发送多少(0.001)<code>以太</code>。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 <code>value</code> 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p>
<blockquote>
<p>注意： 如果一个函数没标记为<code>payable</code>， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p>
</blockquote>
<h1 id="第2章-提现"><a href="#第2章-提现" class="headerlink" title="第2章: 提现"></a>第2章: 提现</h1><p>在你发送以太之后，它将被存储进该合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p>
<p>你可以写一个函数来从合约中提现以太，类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">GetPaid</span> is <span class="title class_">Ownable</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">withdraw</span>(<span class="params"></span>) external onlyOwner &#123;</span><br><span class="line">    owner.<span class="title function_">transfer</span>(<span class="variable language_">this</span>.<span class="property">balance</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们使用 <code>Ownable</code> 合约中的 <code>owner</code> 和 <code>onlyOwner</code>，假定它已经被引入了。</p>
<p>你可以通过 <code>transfer</code> 函数向一个地址发送以太， 然后 <code>this.balance</code> 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， <code>this.balance</code> 将是100以太。</p>
<p>你可以通过 <code>transfer</code> 向任何以太坊地址付钱。 比如，你可以有一个函数在 <code>msg.sender</code> 超额付款的时候给他们退钱：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint itemFee = <span class="number">0.001</span> ether;</span><br><span class="line">msg.<span class="property">sender</span>.<span class="title function_">transfer</span>(msg.<span class="property">value</span> - itemFee);</span><br></pre></td></tr></table></figure>

<p>或者在一个有买家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 <code>seller.transfer(msg.value)</code>。</p>
<p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p>
<h1 id="第3章-僵尸战斗"><a href="#第3章-僵尸战斗" class="headerlink" title="第3章: 僵尸战斗"></a>第3章: 僵尸战斗</h1><h1 id="第4章-随机数"><a href="#第4章-随机数" class="headerlink" title="第4章: 随机数"></a>第4章: 随机数</h1><p>优秀的游戏都需要一些随机元素，那么我们在 Solidity 里如何生成随机数呢？</p>
<p>真正的答案是你不能，或者最起码，你无法安全地做到这一点。</p>
<h2 id="用-keccak256-来制造随机数。"><a href="#用-keccak256-来制造随机数。" class="headerlink" title="用 keccak256 来制造随机数。"></a>用 <code>keccak256</code> 来制造随机数。</h2><p><strong>SHA-3</strong>第三代安全散列算法(Secure Hash Algorithm 3)，之前名为<strong>Keccak</strong>（念作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Help:英語國際音標">/ˈkɛtʃæk/</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Help:英語國際音標">/kɛtʃɑːk/</a>)）算法.</p>
<p>Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.</p>
<p>我们可以这样来生成一些随机数</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个0到100的随机数:</span></span><br><span class="line"><span class="built_in">uint</span> randNonce = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">uint</span> random = <span class="built_in">uint</span>(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br><span class="line">randNonce++;</span><br><span class="line"><span class="built_in">uint</span> random2 = <span class="built_in">uint</span>(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法首先拿到 <code>now</code> 的时间戳、 <code>msg.sender</code>、 以及一个自增数 <code>nonce</code> （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p>
<p>然后利用 <code>keccak</code> 把输入的值转变为一个哈希值, 再将哈希值转换为 <code>uint</code>, 然后利用 <code>% 100</code> 来取最后两位, 就生成了一个0到100之间随机数了。</p>
<h3 id="这个方法很容易被不诚实的节点攻击"><a href="#这个方法很容易被不诚实的节点攻击" class="headerlink" title="这个方法很容易被不诚实的节点攻击"></a>这个方法很容易被不诚实的节点攻击</h3><p>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 <strong><em>transaction\</em></strong> 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 <strong><em>block\</em></strong> 发布在网络上。</p>
<p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p>
<p><strong>这就让我们的随机数函数变得可利用了</strong></p>
<p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (<code>random &gt;= 50</code> 算正面, <code>random &lt; 50</code> 算反面)。</p>
<p>如果我正运行一个节点，我可以 <strong>只对我自己的节点</strong> 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p>
<h2 id="所以我们该如何在以太坊上安全地生成随机数呢"><a href="#所以我们该如何在以太坊上安全地生成随机数呢" class="headerlink" title="所以我们该如何在以太坊上安全地生成随机数呢"></a>所以我们该如何在以太坊上安全地生成随机数呢</h2><p>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 <a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">这个 StackOverflow 上的讨论</a> 来获得一些主意。 一个方法是利用 <strong><em>oracle\</em></strong> 来访问以太坊区块链之外的随机数函数。</p>
<p>因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p>
<p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p>
<h1 id="第5章-僵尸对战"><a href="#第5章-僵尸对战" class="headerlink" title="第5章: 僵尸对战"></a>第5章: 僵尸对战</h1><h1 id="第6章-重构通用逻辑"><a href="#第6章-重构通用逻辑" class="headerlink" title="第6章: 重构通用逻辑"></a>第6章: 重构通用逻辑</h1><h1 id="第7章-更多重构"><a href="#第7章-更多重构" class="headerlink" title="第7章: 更多重构"></a>第7章: 更多重构</h1><h1 id="第8章-回到攻击！"><a href="#第8章-回到攻击！" class="headerlink" title="第8章: 回到攻击！"></a>第8章: 回到攻击！</h1><h1 id="第9章-僵尸的输赢"><a href="#第9章-僵尸的输赢" class="headerlink" title="第9章: 僵尸的输赢"></a>第9章: 僵尸的输赢</h1><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p>
<p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 <code>Zombie</code> 结构体内。</p>
<h1 id="第10章-僵尸胜利了-😄"><a href="#第10章-僵尸胜利了-😄" class="headerlink" title="第10章: 僵尸胜利了 😄"></a>第10章: 僵尸胜利了 😄</h1><h1 id="第11章-僵尸失败-😞"><a href="#第11章-僵尸失败-😞" class="headerlink" title="第11章: 僵尸失败 😞"></a>第11章: 僵尸失败 😞</h1><p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 <code>lossCount</code> 加一，并触发冷却，等待一天后才能再次参战。</p>
<p>实现这个逻辑，我们需要一个 <code>else</code> 语句。</p>
<p><code>else</code> 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zombieCoins[msg.<span class="property">sender</span>] &gt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  <span class="comment">// 你好有钱!!!</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 我们需要更多的僵尸币...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><h1 id="第1章-以太坊上的代币"><a href="#第1章-以太坊上的代币" class="headerlink" title="第1章: 以太坊上的代币"></a>第1章: 以太坊上的代币</h1><p>让我们来聊聊 <strong><em>代币</em></strong>.(tokens)</p>
<p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 <strong><em>ERC20 代币\</em></strong>.</p>
<p>A <strong><em>token\</em></strong> on Ethereum is basically just a smart contract that follows some common rules — namely it implements a standard set of functions that all other token contracts share, such as <code>transferFrom(address _from, address _to, uint256 _tokenId)</code> and <code>balanceOf(address _owner)</code>.</p>
<p>一个代币就是一个智能合约。</p>
<p>一个 <strong><em>代币</em></strong> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如</p>
<p><code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p>
<p>在智能合约内部，通常有一个映射， <code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p>
<p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p>
<h3 id="它为什么重要呢？"><a href="#它为什么重要呢？" class="headerlink" title="它为什么重要呢？"></a>它为什么重要呢？</h3><p>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p>
<p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p>
<p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p>
<p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p>
<h3 id="其他代币标准"><a href="#其他代币标准" class="headerlink" title="其他代币标准"></a>其他代币标准</h3><p>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p>
<p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p>
<p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”<strong>Steve</strong>“完全不能等同于我732级的僵尸”<strong>H4XF13LD MORRIS 💯💯😎💯💯</strong>“。（你差得远呢，<em>Steve</em>）。</p>
<p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为<strong><em>ERC721 代币.\</em></strong></p>
<p><strong><em>ERC721 代币\</em></strong>是<strong>不</strong>能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p>
<blockquote>
<p><em>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</em></p>
</blockquote>
<h1 id="第2章-ERC721-标准-多重继承"><a href="#第2章-ERC721-标准-多重继承" class="headerlink" title="第2章: ERC721 标准, 多重继承"></a>第2章: ERC721 标准, 多重继承</h1><p>让我们来看一看 ERC721 标准：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract <span class="title class_">ERC721</span> &#123;</span><br><span class="line">  event <span class="title class_">Transfer</span>(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event <span class="title class_">Approval</span>(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">balanceOf</span>(<span class="params">address _owner</span>) public view <span class="title function_">returns</span> (uint256 _balance);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ownerOf</span>(<span class="params">uint256 _tokenId</span>) public view <span class="title function_">returns</span> (address _owner);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address _to, uint256 _tokenId</span>) public;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">approve</span>(<span class="params">address _to, uint256 _tokenId</span>) public;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">takeOwnership</span>(<span class="params">uint256 _tokenId</span>) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p>
<blockquote>
<p><em>注意： ERC721目前是一个</em> <em>草稿**，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这</em> <strong>一个</strong> <em>可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</em></p>
</blockquote>
<h3 id="实现一个代币合约"><a href="#实现一个代币合约" class="headerlink" title="实现一个代币合约"></a>实现一个代币合约</h3><p>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import &quot;./erc721.sol&quot;;</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p>
<p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto <span class="keyword">is</span> NickSzabo, HalFinney &#123;</span><br><span class="line">  <span class="comment">// 啧啧啧，宇宙的奥秘泄露了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所见，当使用多重继承的时候，你只需要用逗号 <code>,</code> 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p>
<h1 id="第3章-balanceOf-和-ownerOf"><a href="#第3章-balanceOf-和-ownerOf" class="headerlink" title="第3章: balanceOf 和 ownerOf"></a>第3章: balanceOf 和 ownerOf</h1><h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a><code>balanceOf</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">balanceOf</span>(<span class="params">address _owner</span>) public view <span class="title function_">returns</span> (uint256 _balance);</span><br></pre></td></tr></table></figure>

<p>这个函数只需要一个传入 <code>address</code> 参数，然后返回这个 <code>address</code> 拥有多少代币。</p>
<p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p>
<h3 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf"></a><code>ownerOf</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ownerOf</span>(<span class="params">uint256 _tokenId</span>) public view <span class="title function_">returns</span> (address _owner);</span><br></pre></td></tr></table></figure>

<p>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 <code>address</code>。</p>
<p>同样的，因为在我们的 DApp 里已经有一个 <code>mapping</code> (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 <code>return</code> 语句来实现这个函数。</p>
<blockquote>
<p>注意：要记得， <code>uint256</code> 等同于<code>uint</code>。我们从课程的开始一直在代码中使用 <code>uint</code>，但从现在开始我们将在这里用 <code>uint256</code>，因为我们直接从规范中复制粘贴。</p>
</blockquote>
<h1 id="第4章-重构"><a href="#第4章-重构" class="headerlink" title="第4章: 重构"></a>第4章: 重构</h1><p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p>
<p>所以我们应该把在 <code>ZombieOwnership</code> 里的函数名称改成别的吗？</p>
<p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p>
<p>所以，那意味着我们将必须重构我们第4课中的代码，将 <code>modifier</code> 的名称换成别的。</p>
<h1 id="第5章-ERC721-Transfer-Logic"><a href="#第5章-ERC721-Transfer-Logic" class="headerlink" title="第5章: ERC721: Transfer Logic"></a>第5章: ERC721: Transfer Logic</h1><p>注意 ERC721 规范有两种不同的方法来转移代币：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">transfer</span>(address _to, uint256 _tokenId) <span class="keyword">public</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> approve(address _to, uint256 _tokenId) <span class="keyword">public</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> takeOwnership(uint256 _tokenId) <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一种方法是代币的拥有者调用<code>transfer</code> 方法，传入他想转移到的 <code>address</code> 和他想转移的代币的 <code>_tokenId</code>。</li>
<li>第二种方法是代币拥有者首先调用 <code>approve</code>，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 <code>mapping (uint256 =&gt; address)</code> 里。然后，当有人调用 <code>takeOwnership</code> 时，合约会检查 <code>msg.sender</code> 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</li>
</ol>
<p>你注意到了吗，<code>transfer</code> 和 <code>takeOwnership</code> 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p>
<h1 id="第7章-ERC721-Approval"><a href="#第7章-ERC721-Approval" class="headerlink" title="第7章: ERC721: Approval"></a>第7章: ERC721: Approval</h1><p>记住，使用 <code>approve</code> 或者 <code>takeOwnership</code> 的时候，转移有2个步骤：</p>
<ol>
<li>你，作为所有者，用新主人的 <code>address</code> 和你希望他获取的 <code>_tokenId</code> 来调用 <code>approve</code></li>
<li>新主人用 <code>_tokenId</code> 来调用 <code>takeOwnership</code>，合约会检查确保他获得了批准，然后把代币转移给他。</li>
</ol>
<p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p>
<h1 id="第8章-ERC721-takeOwnership"><a href="#第8章-ERC721-takeOwnership" class="headerlink" title="第8章: ERC721: takeOwnership"></a>第8章: ERC721: takeOwnership</h1><p>最后一个函数 <code>takeOwnership</code>， 应该只是简单地检查以确保 <code>msg.sender</code> 已经被批准来提取这个代币或者僵尸。若确认，就调用 <code>_transfer</code>；</p>
<h1 id="第9章-预防溢出"><a href="#第9章-预防溢出" class="headerlink" title="第9章: 预防溢出"></a>第9章: 预防溢出</h1><p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给<code>0</code> 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p>
<p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p>
<h3 id="合约安全增强-溢出和下溢"><a href="#合约安全增强-溢出和下溢" class="headerlink" title="合约安全增强: 溢出和下溢"></a>合约安全增强: 溢出和下溢</h3><p>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p>
<p>什么是 <strong><em>溢出</em></strong> (<strong><em>overflow\</em></strong>)?</p>
<p>假设我们有一个 <code>uint8</code>, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 <code>11111111</code> (或者说十进制的 2^8 - 1 = 255).</p>
<p>来看看下面的代码。最后 <code>number</code> 将会是什么值？</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 <span class="built_in">number</span> = <span class="number">255</span>;</span><br><span class="line"><span class="built_in">number</span>++;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 <code>number</code> 出乎意料地等于 <code>0</code>了。 (如果你给二进制 <code>11111111</code> 加1, 它将被重置为 <code>00000000</code>，就像钟表从 <code>23:59</code> 走向 <code>00:00</code>)。</p>
<p>下溢(<code>underflow</code>)也类似，如果你从一个等于 <code>0</code> 的 <code>uint8</code> 减去 <code>1</code>, 它将变成 <code>255</code> (因为 <code>uint</code> 是无符号的，其不能等于负数)。</p>
<p>虽然我们在这里不使用 <code>uint8</code>，而且每次给一个 <code>uint256</code> 加 <code>1</code> 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p>
<h3 id="使用-SafeMath"><a href="#使用-SafeMath" class="headerlink" title="使用 SafeMath"></a>使用 SafeMath</h3><p>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <strong><em>库</em></strong>(<strong><em>library\</em></strong>)，默认情况下可以防止这些问题。</p>
<p>不过在我们使用之前…… 什么叫做库?</p>
<p>一个<strong><em>库</em></strong> 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p>
<p>比如，使用 SafeMath 库的时候，我们将使用 <code>using SafeMath for uint256</code> 这样的语法。 SafeMath 库有四个方法 — <code>add</code>， <code>sub</code>， <code>mul</code>， 以及 <code>div</code>。现在我们可以这样来让 <code>uint256</code> 调用这些方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="title class_">SafeMath</span> <span class="keyword">for</span> uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = <span class="number">5</span>;</span><br><span class="line">uint256 b = a.<span class="title function_">add</span>(<span class="number">3</span>); <span class="comment">// 5 + 3 = 8</span></span><br><span class="line">uint256 c = a.<span class="title function_">mul</span>(<span class="number">2</span>); <span class="comment">// 5 * 2 = 10</span></span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>「区块链」：Solidity-advanced</p><p><a href="https://f7ed.com/2020/11/05/solidity-advanced/">https://f7ed.com/2020/11/05/solidity-advanced/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>f7ed</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-05</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-05-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/blockchain/">blockchain, </a><a class="link-muted" rel="tag" href="/tags/solidity/">solidity </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/qrcode_wechat.jpg" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/f7ed" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/qrcode_alipay.jpg" alt="Alipay"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/16/entropy-and-more/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「Math」:Entropy, Cross-Entropy and DL-Divergence</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/03/solidity-basic/"><span class="level-item">「区块链」：Solidity-basic</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "e020519332e0ab0a7acff14cd0b69126",
            repo: "f7ed.github.io",
            owner: "f7ed",
            clientID: "ec59f5258ac0ec443907",
            clientSecret: "f092b308c3e1b46327481c3547ee0dd7fc1bda10",
            admin: ["f7ed"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/profile.png" alt="f7ed"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">f7ed</p><p class="is-size-6 is-block">热爱可抵漫长岁月。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">139</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:f7edliu@outlook.com" target="_blank" rel="noopener">Email me</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Part-1"><span class="level-left"><span class="level-item">1</span><span class="level-item">Part 1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第1章-智能协议的永固性"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">第1章: 智能协议的永固性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外部依赖关系"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">外部依赖关系</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第2章-Ownable-Contracts"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">第2章: Ownable Contracts</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#OpenZeppelin库的Ownable-合约"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">OpenZeppelin库的Ownable 合约</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第3章-onlyOwner-函数修饰符"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">第3章: onlyOwner 函数修饰符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数修饰符"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">函数修饰符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第4章-Gas"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">第4章: Gas</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Gas-驱动以太坊DApps的能源"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">Gas - 驱动以太坊DApps的能源</span></span></a></li><li><a class="level is-mobile" href="#为什么要用-gas-来驱动？"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">为什么要用 gas 来驱动？</span></span></a></li><li><a class="level is-mobile" href="#省-gas-的招数：结构封装-（Struct-packing）"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">省 gas 的招数：结构封装 （Struct packing）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第5章-时间单位"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">第5章: 时间单位</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#时间单位"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">时间单位</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第6章-僵尸冷却"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">第6章: 僵尸冷却</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将结构体作为参数传入"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">将结构体作为参数传入</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第7章-公有函数和安全性"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">第7章: 公有函数和安全性</span></span></a></li><li><a class="level is-mobile" href="#第8章-进一步了解函数修饰符"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">第8章: 进一步了解函数修饰符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#带参数的函数修饰符"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">带参数的函数修饰符</span></span></a></li><li><a class="level is-mobile" href="#带参数的函数修饰符-1"><span class="level-left"><span class="level-item">1.8.2</span><span class="level-item">带参数的函数修饰符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第10章-利用-‘View’-函数节省-Gas"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">第10章: 利用 ‘View’ 函数节省 Gas</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#“view”-函数不花-“gas”"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">“view” 函数不花 “gas”</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第11章-存储非常昂贵"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">第11章: 存储非常昂贵</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#在内存中声明数组"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">在内存中声明数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第12章-For-循环"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">第12章: For 循环</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#这个做法有问题"><span class="level-left"><span class="level-item">1.11.1</span><span class="level-item">这个做法有问题</span></span></a></li><li><a class="level is-mobile" href="#使用-for-循环"><span class="level-left"><span class="level-item">1.11.2</span><span class="level-item">使用 for 循环</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#part-2"><span class="level-left"><span class="level-item">2</span><span class="level-item">part 2</span></span></a></li><li><a class="level is-mobile" href="#第1章-可支付"><span class="level-left"><span class="level-item">3</span><span class="level-item">第1章: 可支付</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#payable-修饰符"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">payable 修饰符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第2章-提现"><span class="level-left"><span class="level-item">4</span><span class="level-item">第2章: 提现</span></span></a></li><li><a class="level is-mobile" href="#第3章-僵尸战斗"><span class="level-left"><span class="level-item">5</span><span class="level-item">第3章: 僵尸战斗</span></span></a></li><li><a class="level is-mobile" href="#第4章-随机数"><span class="level-left"><span class="level-item">6</span><span class="level-item">第4章: 随机数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#用-keccak256-来制造随机数。"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">用 keccak256 来制造随机数。</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#这个方法很容易被不诚实的节点攻击"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">这个方法很容易被不诚实的节点攻击</span></span></a></li></ul></li><li><a class="level is-mobile" href="#所以我们该如何在以太坊上安全地生成随机数呢"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">所以我们该如何在以太坊上安全地生成随机数呢</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第5章-僵尸对战"><span class="level-left"><span class="level-item">7</span><span class="level-item">第5章: 僵尸对战</span></span></a></li><li><a class="level is-mobile" href="#第6章-重构通用逻辑"><span class="level-left"><span class="level-item">8</span><span class="level-item">第6章: 重构通用逻辑</span></span></a></li><li><a class="level is-mobile" href="#第7章-更多重构"><span class="level-left"><span class="level-item">9</span><span class="level-item">第7章: 更多重构</span></span></a></li><li><a class="level is-mobile" href="#第8章-回到攻击！"><span class="level-left"><span class="level-item">10</span><span class="level-item">第8章: 回到攻击！</span></span></a></li><li><a class="level is-mobile" href="#第9章-僵尸的输赢"><span class="level-left"><span class="level-item">11</span><span class="level-item">第9章: 僵尸的输赢</span></span></a></li><li><a class="level is-mobile" href="#第10章-僵尸胜利了-😄"><span class="level-left"><span class="level-item">12</span><span class="level-item">第10章: 僵尸胜利了 😄</span></span></a></li><li><a class="level is-mobile" href="#第11章-僵尸失败-😞"><span class="level-left"><span class="level-item">13</span><span class="level-item">第11章: 僵尸失败 😞</span></span></a></li><li><a class="level is-mobile" href="#Part-3"><span class="level-left"><span class="level-item">14</span><span class="level-item">Part 3</span></span></a></li><li><a class="level is-mobile" href="#第1章-以太坊上的代币"><span class="level-left"><span class="level-item">15</span><span class="level-item">第1章: 以太坊上的代币</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#它为什么重要呢？"><span class="level-left"><span class="level-item">15.1.1</span><span class="level-item">它为什么重要呢？</span></span></a></li><li><a class="level is-mobile" href="#其他代币标准"><span class="level-left"><span class="level-item">15.1.2</span><span class="level-item">其他代币标准</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#第2章-ERC721-标准-多重继承"><span class="level-left"><span class="level-item">16</span><span class="level-item">第2章: ERC721 标准, 多重继承</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#实现一个代币合约"><span class="level-left"><span class="level-item">16.1.1</span><span class="level-item">实现一个代币合约</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#第3章-balanceOf-和-ownerOf"><span class="level-left"><span class="level-item">17</span><span class="level-item">第3章: balanceOf 和 ownerOf</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#balanceOf"><span class="level-left"><span class="level-item">17.1.1</span><span class="level-item">balanceOf</span></span></a></li><li><a class="level is-mobile" href="#ownerOf"><span class="level-left"><span class="level-item">17.1.2</span><span class="level-item">ownerOf</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#第4章-重构"><span class="level-left"><span class="level-item">18</span><span class="level-item">第4章: 重构</span></span></a></li><li><a class="level is-mobile" href="#第5章-ERC721-Transfer-Logic"><span class="level-left"><span class="level-item">19</span><span class="level-item">第5章: ERC721: Transfer Logic</span></span></a></li><li><a class="level is-mobile" href="#第7章-ERC721-Approval"><span class="level-left"><span class="level-item">20</span><span class="level-item">第7章: ERC721: Approval</span></span></a></li><li><a class="level is-mobile" href="#第8章-ERC721-takeOwnership"><span class="level-left"><span class="level-item">21</span><span class="level-item">第8章: ERC721: takeOwnership</span></span></a></li><li><a class="level is-mobile" href="#第9章-预防溢出"><span class="level-left"><span class="level-item">22</span><span class="level-item">第9章: 预防溢出</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#合约安全增强-溢出和下溢"><span class="level-left"><span class="level-item">22.1.1</span><span class="level-item">合约安全增强: 溢出和下溢</span></span></a></li><li><a class="level is-mobile" href="#使用-SafeMath"><span class="level-left"><span class="level-item">22.1.2</span><span class="level-item">使用 SafeMath</span></span></a></li></ul></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 f7ed</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="f7ed&#039;s GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script>
      var sc_project=12961083;
      var sc_invisible=1;
      var sc_security="ad3fb575";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12961083/0/ad3fb575/1/" alt="real time web analytics"></div></noscript><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>