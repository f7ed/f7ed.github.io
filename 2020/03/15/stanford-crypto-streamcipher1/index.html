<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「Cryptography-Boneh」:Stream Cipher 1 - fred&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fred&#039;s blog"><meta name="msapplication-TileImage" content="/img/heart.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fred&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Stream Cipher的第一部分：介绍了One Time Pad和Stream Cipher中的PRG。其中OTP部分叙述了什么是Perfect Secrecy？为什么OTP很难在实践中应用？Stream Cipher部分中，本文主要阐述了什么是PRG？Stream Cipher的另一种安全的定义（依靠PRG的unpredictable)。本文后半部分，详细阐述了一种weak PRG——线性同"><meta property="og:type" content="blog"><meta property="og:title" content="「Cryptography-Boneh」:Stream Cipher 1"><meta property="og:url" content="https://f7ed.com/2020/03/15/stanford-crypto-streamcipher1/"><meta property="og:site_name" content="fred&#039;s blog"><meta property="og:description" content="Stream Cipher的第一部分：介绍了One Time Pad和Stream Cipher中的PRG。其中OTP部分叙述了什么是Perfect Secrecy？为什么OTP很难在实践中应用？Stream Cipher部分中，本文主要阐述了什么是PRG？Stream Cipher的另一种安全的定义（依靠PRG的unpredictable)。本文后半部分，详细阐述了一种weak PRG——线性同"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://f7ed.com/gallery/thumbnails/0315.png"><meta property="article:published_time" content="2020-03-14T16:00:00.000Z"><meta property="article:modified_time" content="2021-12-28T06:29:27.509Z"><meta property="article:author" content="f7ed"><meta property="article:tag" content="公开课"><meta property="article:tag" content="Cryptography"><meta property="article:tag" content="StreamCipher"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/thumbnails/0315.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://f7ed.com/2020/03/15/stanford-crypto-streamcipher1/"},"headline":"「Cryptography-Boneh」:Stream Cipher 1","image":["https://f7ed.com/gallery/thumbnails/0315.png"],"datePublished":"2020-03-14T16:00:00.000Z","dateModified":"2021-12-28T06:29:27.509Z","author":{"@type":"Person","name":"f7ed"},"publisher":{"@type":"Organization","name":"fred's blog","logo":{"@type":"ImageObject","url":"https://f7ed.com/img/f1ed_logo.png"}},"description":"Stream Cipher的第一部分：介绍了One Time Pad和Stream Cipher中的PRG。其中OTP部分叙述了什么是Perfect Secrecy？为什么OTP很难在实践中应用？Stream Cipher部分中，本文主要阐述了什么是PRG？Stream Cipher的另一种安全的定义（依靠PRG的unpredictable)。本文后半部分，详细阐述了一种weak PRG——线性同"}</script><link rel="canonical" href="https://f7ed.com/2020/03/15/stanford-crypto-streamcipher1/"><link rel="icon" href="/img/heart.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-M5KG3CQTSF" async></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-M5KG3CQTSF');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="fred's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/liu">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-bars"></i>「Cryptography-Boneh」:Stream Cipher 1</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2020-03-14T16:00:00.000Z" title="2020-03-14T16:00:00.000Z">2020-03-15</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-12-28T06:29:27.509Z" title="2021-12-28T06:29:27.509Z">2021-12-28</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/Cryptography-Boneh/">Cryptography-Boneh</a></span><span class="level-item"><i class="far fa-clock"></i> 29 minutes read (About 4412 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>Stream Cipher的第一部分：介绍了One Time Pad和Stream Cipher中的PRG。<br>其中OTP部分叙述了什么是Perfect Secrecy？为什么OTP很难在实践中应用？<br>Stream Cipher部分中，本文主要阐述了什么是PRG？Stream Cipher的另一种安全的定义（依靠PRG的unpredictable)。<br>本文后半部分，详细阐述了一种weak PRG——线性同余生成器，它是如何工作的？它为什么不安全？如何攻击它?</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="more"></span>

<h1 id="The-One-Time-Pad"><a href="#The-One-Time-Pad" class="headerlink" title="The One Time Pad"></a>The One Time Pad</h1><h2 id="Symmetric-Ciphers-difinition"><a href="#Symmetric-Ciphers-difinition" class="headerlink" title="Symmetric Ciphers: difinition"></a>Symmetric Ciphers: difinition</h2><p><strong>Def</strong> <em>:a cipher difined over $\mathcal{(K,M,C)}$  is a pair of “efiicient “ algorithms $(E,D)$ where</em></p>
 
$$
E :\mathcal{K \times M \longrightarrow \mathcal{C}} \quad ,\quad D:\mathcal{K\times\mathcal{C}\longrightarrow\mathcal{M}} \\ s.t. \quad \forall m\in \mathcal{M},k\in \mathcal{K}:D(k,E(k,m))=m
$$


<hr>
<p>$\mathcal{(K,M,C)}$ 分别是密钥空间、明文空间、密文空间。</p>
<p>对称加密其实是定义在$\mathcal{(K,M,C)}$ 的两个有效算法 $(E,D)$ ，这两个算法满足consistence equation(一致性方程)：$D(k,E(k,m))=m$ 。</p>
<p>一些说明：</p>
<ol>
<li><p>$E$ is ofen randomized. 即加密算法E总是随机生成一些bits，用来加密明文。</p>
</li>
<li><p>$D$ is always deterministic. 即当确定密钥和明文时，解密算法的输出总是唯一的。</p>
</li>
<li><p>“efficient” 的含义</p>
<ul>
<li>对于理论派：efficient表示 in polynomial time（多项式时间）</li>
<li>对于实践派：efficient表示 in a certain time</li>
</ul>
</li>
</ol>
<h2 id="One-Time-Pad-OTP"><a href="#One-Time-Pad-OTP" class="headerlink" title="One Time Pad(OTP)"></a>One Time Pad(OTP)</h2><h3 id="Definition-of-OTP"><a href="#Definition-of-OTP" class="headerlink" title="Definition of OTP"></a>Definition of OTP</h3><p>The one time pad(OTP) 又叫一次一密。</p>
<p><strong>用对称加密的定义来表示OTP：</strong></p>
<ul>
<li>$\mathcal{M=C=}{0,1}^n\quad \mathcal{K}={0,1}^n$ </li>
<li>$E：\quad c = E(k,m)=k\oplus m \quad$</li>
<li>$D:\quad m = D(k,c)=k\oplus c$ </li>
</ul>
<p>明文空间和密文空间相同，密钥空间也是n位01串集合。</p>
<p>而且，在OTP中，密钥key的长度和明文message长度一样长。</p>
<img src="https://s1.ax1x.com/2020/03/15/81TrSs.png" alt="81TrSs.png" style="zoom:50%;" />

<p>加密过程如上图所示。</p>
<ul>
<li><p><strong>证明其一致性方程</strong></p>
<p><strong>Indeed</strong> ： </p>
<p>$D(k,E(k,m))=D(k,k\oplus m)=k\oplus (k\oplus m)=0\oplus m=m$ </p>
</li>
</ul>
<hr>
<p>但是OTP加密安全吗？</p>
<p>如果已知明文(m)和他的OTP密文(c)，可以算出用来加密m的OTP key吗？</p>
<p>：当然，根据异或的性质，key $k=m\oplus c$ </p>
<p>所以什么是安全呢？</p>
<h3 id="Information-Theoretic-Security"><a href="#Information-Theoretic-Security" class="headerlink" title="Information Theoretic Security"></a>Information Theoretic Security</h3><p>根据Shannon 1949发表的论文，<strong>Shannon’s basic idea: CT(Ciphertext) should reveal no “info” about PT(Plaintext)</strong>，即密文不应该泄露明文的任何信息。</p>
<h4 id="Perfect-Security-Def"><a href="#Perfect-Security-Def" class="headerlink" title="Perfect Security Def:"></a><strong><u>Perfect Security Def:</u></strong></h4><p>A cipher $(E,D)$ over  $\mathcal{(K,M,C)}$ has <strong>perfect security</strong> if $\forall m_0,m_1 \in \mathcal{M}\ (|m_0|=|m_1|) \quad \text{and} \quad \forall c\in \mathcal{C} $<br>$$<br>Pr[E(k,m_0)=c]=Pr[E(k,m_1)=c] \qquad \text{where} \ k\overset{R}{\longleftarrow}\mathcal{K}<br>$$</p>
<hr>
<blockquote>
<p>$k \overset{R}\longleftarrow \mathcal{K}$  的意思是 $k$ 是 从$\mathcal{K}$ 中随机取的，即随机变量 $k$ 的取值是均匀分布。</p>
</blockquote>
<p>对任意 $m_0,m_1$ （并且message长度相同），那么在密钥空间任意取 $k$  , $k$ 将 $m_0,m_1$ 加密为相同密文的概率相同。</p>
<h4 id="对attacker来说-："><a href="#对attacker来说-：" class="headerlink" title="对attacker来说 ："></a><strong>对attacker来说</strong> ：</h4><p>攻击者截取一段密文c，那么c是由 $m_0,m_1$ 加密而来的概率是相同的，即攻击者也不知道明文到底是 $m_0$ 还是 $m_1$ （因为概率相同）。</p>
<ul>
<li><p>$\Rightarrow$ Given CT can’t tell if msg is $m_0 \ \text{or}\ m_1 $ (for all $m_i$  ) .   </p>
<p>【攻击者不能区分明文到底是 $m_?$ 】</p>
</li>
<li><p>$\Rightarrow$ most powerful adv.(adversary) learns nothing about PT from CT.   </p>
<p>【不管攻击者多聪明，都不能从密文中得到密文的信息】</p>
</li>
<li><p>$\Rightarrow$ no CT only attack!! (but other attackers possible).    </p>
<p>【唯密文攻击对OTP无效】</p>
</li>
</ul>
<h3 id="OTP-has-perfect-secrecy"><a href="#OTP-has-perfect-secrecy" class="headerlink" title="OTP has perfect secrecy"></a>OTP has perfect secrecy</h3><p><strong><u>Lemma</u></strong> : <em>OTP has perfect secrecy.</em></p>
<p>用上一小节的perfect securecy的定义来证明这个引理。</p>
<p><strong>Proof</strong>：</p>
<ol>
<li><p>要证明： $Pr[E(k,m_0)=c]=Pr[E(k,m_1)=c] \qquad \text{where} \ k\overset{R}{\longleftarrow}\mathcal{K}$ </p>
</li>
<li><p>表达式： $\forall m, c: \quad \operatorname{Pr}_{k}[E(k,m)=c]=\frac{\# \text{keys} \  k \in \mathcal{K} \quad s.t.\; E(k,m)=c}{|\mathcal{K}|}$ </p>
<p>对于任意m,c,  $\operatorname{Pr}_{k}[E(k,m)=c]$  等于能将m加密为c的密钥个数除以密钥空间的大小。</p>
</li>
<li> $\because |\mathcal{K}|$ 是相同的，所以即证 ： $\{ \# \text{keys} \  k \in \mathcal{K} \quad s.t.\; E(k,m)=c \}=\text{const}$ 
</li>
<li><p>对于任意 m,c，能将m加密为c的OTP key只有一个： $k=m\oplus c$</p>
</li>
<li><p>$\therefore$ OTP has perfect secrecy.</p>
<h3 id="key-len-geq-msg-len"><a href="#key-len-geq-msg-len" class="headerlink" title="key-len $\geq$ msg-len"></a>key-len $\geq$ msg-len</h3></li>
</ol>
<p>Perfect Secrecy的性质带来了一个bad news。</p>
<p><strong><u>Thm</u></strong>: <em>perfect secrecy $\Rightarrow$   $|\mathcal{K}|\geq|\mathcal{M}|$</em> </p>
<p>如果一个cipher满足perfect secrecy,那么其密钥的长度必须大于等于明文长度。这也是perfect secrecy的必要条件。</p>
<p>所以OTP是perfect secrecy的最优情况，$|\mathcal{K}|=|\mathcal{M}|$ ，密钥长度等于明文长度。</p>
<hr>
<p>为什么说是一个bad news呢？</p>
<p>如果Alice用OTP给Bob发一段msg，在她发之前，她需要先发一个和msg等长的key，这个key只有Alice和Bob知道。</p>
<p>所以如果Alice有能保密传输key的方法，那她何不直接用这个方法传输msg呢？</p>
<p>所以OTP : <strong>hard to use in practice!</strong>  (long key-len)</p>
<p>因此，我们需要key-len短的cipher。</p>
<h1 id="Pseudorandom-Generators（伪随机数生成器）"><a href="#Pseudorandom-Generators（伪随机数生成器）" class="headerlink" title="Pseudorandom Generators（伪随机数生成器）"></a>Pseudorandom Generators（伪随机数生成器）</h1><h2 id="Stream-Ciphers-making-OTP-practical"><a href="#Stream-Ciphers-making-OTP-practical" class="headerlink" title="Stream Ciphers: making OTP practical"></a>Stream Ciphers: making OTP practical</h2><p>Stream Ciphers（流密码）的思想就是：用PRG（pseudorandom Generators） key 代替 “random” key。</p>
<p><strong>PRG</strong>其实就是一个function  G：${ 0,1 }^s\longrightarrow { 0,1 }^n \quad, n&gt;&gt;s$ 。</p>
<p>通过函数将较小的seed space映射到大得多的output space。</p>
<p><strong>注意：</strong> function G is eff. computable by a deterministic algorithm.</p>
<ul>
<li>函数G是确定的，随机的只有s，s也是G的输入。</li>
<li>PRG的输出应该是 “look random”（下文会提到的PRG必须是unpredictable）</li>
</ul>
<img src="https://s1.ax1x.com/2020/03/15/81TUw8.md.png" alt="81TUw8.md.png" style="zoom:70%;" />

<p>Stream Ciphers的过程如上图所示：通过PRG，将长度较短的k映射为足够长的G(k)，G(k)异或m得到密文。</p>
<hr>
<p>有两个问题？</p>
<p>第一，Stream Cipher安全吗？为什么安全？</p>
<p>第二，Stream Cipher have perfect secrecy?</p>
<p>现在，只能回答第二个问题。</p>
<p>：流密码没有perfect secrecy。因为它不满足key-len $\geq$ msg-len，流密码的密钥长度远小于明文长度。</p>
<p>流密码没有perfect secrecy，所以我们还需要引入另一种安全，这种安全和PRG有关。</p>
<h2 id="PRG-must-be-unpredictable"><a href="#PRG-must-be-unpredictable" class="headerlink" title="PRG must be unpredictable"></a>PRG must be unpredictable</h2><p>PRG如果predictable，流密码安全吗？</p>
<h3 id="Suppose-predictable"><a href="#Suppose-predictable" class="headerlink" title="Suppose predictable"></a>Suppose predictable</h3><p>假设PRG是可预测的，即：</p>

$ \exists:\quad G(k)|_{1,2,...,i}\quad \overset{alg.}\longrightarrow \quad G(k)|_{i+1,...,n} $


<p>已知G(k)输出的前i bis，存在一种算法，能计算G(k)的后面剩余的bits。</p>
<img src="https://s1.ax1x.com/2020/03/15/81TNef.png" alt="81TNef.png" style="zoom:67%;" />

<p>攻击如上图所示：</p>
<ol>
<li><p>如果attacker has prior knowledge：已知一段密文前缀的对应明文（m斜线字段）（比如在SMTP协议中，报文的开头总是”from”）</p>
</li>
<li><p>attacker将该密文字段与已知明文字段异或，得到G(k)的前缀。</p>
</li>
<li><p>因为PRG是可预测的，所以可以通过G(k)的前缀计算出G(k)的剩下部分。</p>
</li>
<li><p>得到的G(K)就可以恢复m。</p>
</li>
</ol>
<p>即使，G(k)只能预测后一位，即  $\quad G(k)|_{1,2,...,i}\quad \overset{alg.}\longrightarrow \quad G(k)|_{i+1}$  ，也不安全，当预测出下一位时，又得到了新的前缀，最终得到完整的G(k)。</p>
<p>所以当PRG可预测时，流密码就不安全了。</p>
<p><strong>所以用Stream Cipher时，PRG必须unpredictable!</strong> </p>
<h3 id="Predictable-difinition"><a href="#Predictable-difinition" class="headerlink" title="Predictable: difinition"></a>Predictable: difinition</h3><p><strong><u>Predictable Def</u></strong> :</p>

$ \exists $ "eff" alg. A and	 $\exists$ $0\leq i\leq n-1$ ， s.t. $Pr_{k \overset{R}\leftarrow \mathcal{K} }  {[A(G(k)|_{1,2,...,i})=G(k)|_{i+1}]}>1/2 +\epsilon$ 

<p><em>for non-negligible</em> $\epsilon$ (e.g. $\epsilon=1/2^{30}$)</p>
<p>可预测：即存在算法，通过G(k)的前i位可以计算出第i+1位的概率大于1/2 + $\epsilon$ (不可忽略的值)</p>
<p><strong><u>Unpredictable Def</u></strong> :</p>
<p>即predictable的反面， $\forall i$ : no “eff.” adv. can predict bit(i+1) for “non-neg” $\epsilon$ .</p>
<hr>
<p>Q：假设 $\mathrm{G}: \mathrm{K} \rightarrow{0,1}^{\mathrm{n}} $ ，满足XOR(G(k))=1，G可预测吗？</p>
<p>W：G可预测，存在i = n-1,因为当已知前n-1位,可以预测第n位。</p>
<h2 id="Weak-PRGs"><a href="#Weak-PRGs" class="headerlink" title="Weak PRGs"></a>Weak PRGs</h2><h3 id="Linear-Congruential-Generators"><a href="#Linear-Congruential-Generators" class="headerlink" title="Linear Congruential Generators"></a>Linear Congruential Generators</h3><p>一种应该永远不在安全应用中使用PRG——LCG（linear congruential generators）(线性同余随机生成器)。</p>
<p>虽然他们在应用中使用很快，而且其输出还有良好的统计性质（比如0的个数和1的个数基本相等等），但他们应该never be used for cryptographic。</p>
<p>因为在实践中，给出LCG输出的一些连续序列，很容易计算出输出的剩余序列。</p>
<h3 id="Basic-LCG"><a href="#Basic-LCG" class="headerlink" title="Basic LCG"></a>Basic LCG</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>Basic LCG has four public system parameters: </p>
<p>an integer q, two constants a,b $\in { 0,…,q-1}$ , and a positive integer $w\leq q$ . </p>
<p>The constant a is taken to be relatively prime to q.</p>
<p>【有四个公开参数：整数q，两个q剩余系下的常数a,b，（a与q互素）和一个小于等于q的正整数w。】</p>

We use $\mathcal{S}_q$ and $\mathcal{R}$ to denote the sets: 
$\mathcal{S}_{q}:=\{0, \ldots, q-1\} ; \quad \mathcal{R}:=\{0, \ldots,\lfloor(q-1) / w\rfloor\}$


Now, the generators $G_{\mathrm{lcg}}: \mathcal{S}_{q} \rightarrow \mathcal{R} \times \mathcal{S}_{q}$ with seed $s\in\mathcal{S}_{q}$  defined as follows:
$G_{\operatorname{lcg}}(s):=(\lfloor s / w\rfloor, \quad a s+b \bmod q)$

<p>【LCG的输出是一对数，$(\lfloor s / w\rfloor, \quad a s+b \bmod q)$ 】</p>
<p>当 $w=2^t$ 时，$\lfloor s / w\rfloor$  simply erases the t least significant bits of s【右移t位】。</p>
<h4 id="Insecure"><a href="#Insecure" class="headerlink" title="Insecure"></a>Insecure</h4><p>当已知 $s^{\prime}:=a s+b \bmod q$ ，即可直接求出s，也就求出了所谓的随机数 $\lfloor s/w\rfloor$ .</p>
<h3 id="Variant-Blum-Micali-construction"><a href="#Variant-Blum-Micali-construction" class="headerlink" title="Variant: Blum-Micali construction"></a>Variant: Blum-Micali construction</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/81TaTS"><img src="https://s1.ax1x.com/2020/03/15/81TaTS.md.png" alt="81TaTS.md.png"></a> </p>
<p>如上图所示，变体的LCG是一个迭代，输出不包括 $s_i$ ，把 $r_1,…,r_n$ 作为一次迭代的输出。</p>
<p>不同的应用系统使用不同的 $q,a,b,w$ 参数，在Java 8 Development Kit（JDKv8）中，$q=2^{48}$ , $w=2^{22}$ ,constant $a=\text{0x5DEECE66D}$ ,  $b=\text{0x0B}$ 。</p>
<p>所以在JDKv8中, LCG的输出其实是 $s_i$（48bits） 的前48-22=26 bits 。</p>
<p>显然JDKv8中的参数大小应用在安全系统中，还是太不安全了。</p>
<h4 id="how-to-attack-in-JDKv8"><a href="#how-to-attack-in-JDKv8" class="headerlink" title="how to attack in JDKv8"></a>how to attack in JDKv8</h4><ol>
<li><p>在迭代的第一次输出中，LCG就 reveal 26bits of the seed s。</p>
</li>
<li><p>对于s剩下的后22个bits，attacker can easily recover them by exhausitive search(穷举)：</p>
</li>
<li><p>对于每个可能的取值，attacker都能得到一个候选seed $\hat{s}$ </p>
</li>
<li><p>用 $\hat{s}$ 来验证我们所直接得到的LCG的输出。</p>
</li>
<li><p>如果 $\hat{s}$ 验证失败，则到第三步继续穷举。直至验证成功。</p>
</li>
<li><p>当穷举至正确的s时，就可以直接预测LCG的剩余输出。</p>
</li>
</ol>
<p>在现代处理器中，穷举 $2^{22}$ (4 million) 只需要1秒。所以LCG的参数较小时，是很容易attack。</p>
<p>当 $q=2^{512}$ 时，这种穷举的攻击方法就失效了。但是有一种对于LCG的著名攻击方法[1]，即使每次迭代，LCG只输出较少的bits，也能从这些较少的但连续的输出序列中预测出整个LCG输出序列。</p>
<h3 id="Cryptanalysis-：elegant-attack"><a href="#Cryptanalysis-：elegant-attack" class="headerlink" title="Cryptanalysis ：elegant attack"></a>Cryptanalysis ：elegant attack</h3><h4 id="Warning-of-Math"><a href="#Warning-of-Math" class="headerlink" title="Warning of Math"></a><font color=#f00>Warning of Math</font></h4><h4 id="Suppose"><a href="#Suppose" class="headerlink" title="Suppose"></a>Suppose</h4><p>Suppose : q is large (e.g. $q=2^{512}$  ), and $G_{lcg}^{(n)}$ outputs about half the bits of the state s per iteration.</p>
<p>【q很大， $G_{lcg}^{(n)}$ 每次输出s的一半左右的bits】</p>
<p>More precisely, suppose: $w&lt;\sqrt{q}/c$  for fixed c（e.g. $c=32$ ）</p>
<p>【保证输出s前一半左右bits的这个条件】</p>
<p>Suppose the attacker is given two consecutive outputs of the gnerator $r_i,r_{i+1}\in \mathcal{R}$ .</p>
<p>【已知两个连续输出 $r_i,r_{i+1}\in \mathcal{R}$ 】</p>
<h4 id="Attacker-Knows"><a href="#Attacker-Knows" class="headerlink" title="Attacker Knows"></a>Attacker Knows</h4><ol>
<li><p>$r_{i}=\left\lfloor s_{i} / w\right\rfloor \quad \text { and } \quad r_{i+1}=\left\lfloor s_{i+1} / w\right\rfloor=\left\lfloor\left(a s_{i}+b \bmod q\right) / w\right\rfloor$ </p>
<p>【已知： $r_i,r_{i+1},w,a,b,q$；未知： $s_i$ 】</p>
</li>
<li><p>$r_{i} \cdot w+e_{0}=s \quad \text { and } \quad r_{i+1} \cdot w+e_{1}=a s+b+q x \qquad (0\leq e_0,e_1&lt;w&lt;\sqrt{q}/c)$  </p>
<p>【 去掉floor符号和mod：$e_0,e_1$  是 $s_i,s_{i+1}$ 除 $w$ 的余数】</p>
<p>【已知： $r_i,r_{i+1},w,a,b,q$；未知： $s_i,e_0,e_1,x$ 】</p>
</li>
<li><p>re-arranging: put $x$ and $s$ on the left</p>
<p>$s=r_{i} \cdot w+e_{0} \quad \text { and } \quad a s+q x=r_{i+1} w-b+e_{1}$ </p>
<p>【把未知参数s，x放在等式左边，方便写成矩阵形式】</p>
</li>
<li><p>$s \cdot\left(\begin{array}{l}1 \ a\end{array}\right)+x \cdot\left(\begin{array}{l}0 \ q\end{array}\right)=\boldsymbol{g}+\boldsymbol{e} \quad \text { where } \quad \boldsymbol{g}:=\left(\begin{array}{c}r_{i} w \ r_{i+1} w-b\end{array}\right) \quad \text { and } \quad \boldsymbol{e}:=\left(\begin{array}{c}e_{0} \ e_{1}\end{array}\right)$ </p>
<p>【已知： $\boldsymbol{g},a,q$ ，未知：$\boldsymbol{e},s,x$ 】 </p>
</li>
<li><p>to break the generator it suffices to find the vector $\boldsymbol{u}:=\boldsymbol{g}+\boldsymbol{e}$ .</p>
<p>【令 $u\in {Z}^2$ , $\boldsymbol{u}:=\boldsymbol{g}+\boldsymbol{e}=s \cdot(1, a)^{\mathrm{T}}+x \cdot(0, q)^{\mathrm{T}}$ 】</p>
<p>【如果我们求出了 $\boldsymbol{u}$ ，那可以用线性代数的知识解出 $s$ 和 $x$ ,再用 $s$ 来预测PRG的剩下输出】</p>
</li>
<li><p>konws $\boldsymbol{g}$ ,  knows $\boldsymbol{e}$ is shorter, and $|\boldsymbol{e} |_{\infty}$ is at most $\sqrt{q}/c$ , knows that $\boldsymbol{u}$ is “close” to $\boldsymbol{g}$ .</p>
<p>【e向量很小，$|\boldsymbol{e} |_{\infty}$ 上界是$\sqrt{q}/c$ ，u离g很近】</p>
</li>
</ol>
<blockquote>
<p><strong>Taxicab norm or Manhattan(1-norm)</strong></p>
  ${\|}A{\|}_1=\max \{ \sum|a_{i1}|,\sum|a_{i2}|,...,\sum|a_{in}| \}$  （列和范数，A矩阵每一列元素绝对值之和的最大值）

<p><strong>Euclidean norm(2-norm)</strong>  </p>
  $\|\mathbf{x}\|=\left(\sum_{i=1}^{n}\left|x_{i}\right|^{2}\right)^{1 / 2}$  

<p><strong>$\infty$-范数</strong></p>
  $\|A\|_{\infty}=\max \{ \sum|a_{1j}|,\sum|a_{2j}|,...,\sum|a_{mj}| \}$ （行和范数，A矩阵每一行元素绝对值之和的最大值）
</blockquote>
<ol start="7">
<li><p>attack can figure the lattice with attacking LCG.</p>
<img src="https://s1.ax1x.com/2020/03/15/81T0YQ.md.png" alt="81T0YQ.md.png" style="zoom:67%;" />

<p>the lattice is generated by the vectors $(1,5)^T$ and $(0,29)^T$ , the attacker has a vector $\boldsymbol{g}=(9,7)^T$ and wishes to find the closest lattice vector $\boldsymbol{u}$ .</p>
<p>【上图是  $(1,5)^T$ 和 $(0,29)^T$ 两个向量生成的的格点，希望能从以上格点找到离已知 $\boldsymbol{g}$ 向量最近的格点】</p>
</li>
</ol>
<blockquote>
<p>$\mathcal{L}_a$ :由 $(1, a)^{\mathrm{T}},(0, q)^{\mathrm{T}}$ 作为基向量生成的点集合。</p>
</blockquote>
<ol start="8">
<li><p>The problem is a special case of a general problem call the <strong>closest vector problem</strong>: given a lattice $\mathcal{L}$ and a vector $\boldsymbol{g}$ ,find a vector in $\mathcal{L}$ that is closest to $\mathcal{g}$ .</p>
<p>There is an efficient  polynomial time algorithm for this problem.[2]</p>
<p>【问题归结于 closest vector problem问题，在已知栅格点集合中找离某一向量最近的点，此问题已有多项式时间算法】</p>
</li>
</ol>
<h4 id="step-8-above"><a href="#step-8-above" class="headerlink" title="step 8 above"></a>step 8 above</h4><p><strong><u>Lemma</u></strong> :<br> * For at least $(1-16/c^2)\cdot q $ of the a in $\mathcal{S}_q$ , the lattice $\mathcal{L}_a\sub Z_2$  has the following property: for every $\boldsymbol{g} \in Z^2$ there is at most one vector $\boldsymbol{u}\in \mathcal{L}_a$ such that $\|\boldsymbol{g}-\boldsymbol{u}\|_{\infty}<\sqrt{q}/c$ . *</p>
<p>【假设c=32，这个定理表示的意思是：a在$\mathcal{S}_q$ 的所有取值，有98%的取值保证了 $\mathcal{L}_a$ 中离向量 $\boldsymbol{g}$ 最近的点就是我们所求的 $\boldsymbol{u}$ 】</p>
<p>Armed with this algorithm the attacker can recover the internal state $s_i$  of the LCG generator from just two outputs $r_i,r_{i+1}$  of the generator and predict the remaining sequence. This attack works for 98% of the $a\in \mathcal{S}_q$.</p>
<p>【这个定理，可以保证文献中那个多项式算法[2]可以解决98%的a的取值】</p>
<p>For completeness we note that some example $a\in \mathcal{S}_q$ in the 2% where the attack fails are a = 1</p>
<p>and a = 2. For these a there may be many lattice vectors in $\mathcal{L}_a$ close to a given $\boldsymbol{g}$ .</p>
<p>【剩下2%的取值，是a=1,a=2这种取值很小的情况，因为Lattice中格点都离太近了】</p>
<h4 id="Warning-of-Math！！！（建议清醒的时候看）"><a href="#Warning-of-Math！！！（建议清醒的时候看）" class="headerlink" title="Warning of Math！！！（建议清醒的时候看）"></a><font color=#f00>Warning of Math！！！</font>（建议<del>清醒的时候</del>看）</h4><h4 id="Proof-of-lemma"><a href="#Proof-of-lemma" class="headerlink" title="Proof of lemma"></a><u>Proof of lemma</u></h4><ul>
<li><p>suppose:   there are two vectors $u_0,u_1$ close to $g$ , that is , $\left\|\boldsymbol{u}_{i}-\boldsymbol{g}\right\|_{\infty}<\sqrt{q} / c \text { for } i=0,1$ . </p>
<p>【反证：假设有两个u1,u2离向量g很近，那么u1,u2也离的很近】</p>
</li>
<li> by the triangle inequality, have $\left\|\boldsymbol{u}_{0}-\boldsymbol{u}_{1}\right\|_{\infty} \leq\left\|\boldsymbol{u}_{0}-\boldsymbol{g}\right\|_{\infty}+\left\|\boldsymbol{g}-\boldsymbol{u}_{1}\right\|_{\infty} \leq 2 \sqrt{q} / c$ .

<p>【三角不等式得到， $\boldsymbol{u}_0-\boldsymbol{u}_1$ 的行和范数最大是 $\sqrt{q} / c$ 】</p>
</li>
<li>$\boldsymbol{u}:=\boldsymbol{u}_{0}-\boldsymbol{u}_{1}$ is a vector in $\mathcal{L}_a$ ,and $\mathcal{L}_a$ conclude a "short" vector of non-zero vecor of norm at most $B= 2\sqrt{q} / c$ . Let's bound the number of bad a's for which $\mathcal{L}_a$  contains such a "short vector".

<p>【向量集合的加法封闭性，$\mathcal{L}_a$ 中有一种”short vector”, 他的行和范数最大是$2\sqrt{q} / c$】</p>
<p>【我们去找有多少个”short vector” (number of bad a的最大值)，使得有两点$ \boldsymbol{u}_0,\boldsymbol{u}_1$ 都离 $\boldsymbol{g}$ 很近】 </p>
</li>
<li><p>set $\boldsymbol{t}=(s, y)^{\mathrm{T}} \in \mathbb{Z}^{2}$ be the “short vector” such that $|t|_{\infty} \leq B$ .</p>
</li>
<li><p>【以下情况讨论可以用一般同余方程 $y=a s(\bmod q)$  求通解的推导过程来理解】</p>
</li>
<li><p>first consider the case when q is prime.</p>
<p>【先考虑q是素数的情况】</p>
<ol>
<li> $\boldsymbol{t}$ 是$\mathcal{L}_a$ 中的点：存在 $s_a,x_a$ 让 $s_{a} \cdot(1, a)^{\mathrm{T}}+x_{a} \cdot(0, q)^{\mathrm{T}}=\boldsymbol{t}=(s, y)^{\mathrm{T}}$ 等式成立。
</li>
<li><p>$\Rightarrow$ $s=s_a$  和  $y=as_a\pmod{q}$ , 而且 $s\neq0$ 。</p>
</li>
<li><p>$y=as\pmod{q}$ ，由于q是素数， $a$ 可以唯一确定，得到 $a=y s^{-1} \bmod q$ 。</p>
</li>
<li><p>Hence, when q is prime, every non-zero short vector t is contained in at most one lattice $\mathcal{L}_a$ for some $a\in \mathcal{S}_q$ .</p>
<p>【每一个 $\boldsymbol{t}$  都最多唯一对于 $\mathcal{L}_a$ 中的一个a】</p>
</li>
<li><p>∞-范数的图如下图，所以”short vector” 的个数不超过这个正方形中的格点数，即 $=(2B)^2=16q/c^2$ </p>
<img src="https://s1.ax1x.com/2020/03/15/81TYOP.png" alt="81TYOP.png" style="zoom:50%;" />
</li>
<li><p>表述：<strong>当 $q$ 是素数时，每一个 “short vector” 对应一个 $a$ 的取值。</strong></p>
<p>表述： $a$ 最多有 $16q/c^2$ 个。</p>
</li>
</ol>
</li>
<li><p>second consider the case when q is not prime.</p>
<ol>
<li><p>$y=a s(\bmod q)$ ,q 不是质数，令 $d=\gcd(s,q)$ ，y肯定也是d的倍数</p>
</li>
<li><p>$\Rightarrow y/d=a\cdot s/d \pmod{q/d}$ ,且 $\gcd(s/d,q/d)=1$ </p>
</li>
<li><p>$a_0$ 是 $a$ 在 mod $q/d$ 下的逆元。【同余方程的通解推导过程可以去看看】</p>
</li>
<li><p>那么$y/d=a\cdot s/d \pmod{q/d}$ 中解 $a=a_0\cdot y/d$ </p>
</li>
<li><p>$y=a s(\bmod q)$ 的通解就是 $a=a_0\cdot y/d + k\times q/d$  ($k=0,1,…d-1$  ) ，解数是 $d$ .</p>
</li>
<li><p>表述：$y$ 最多有 $2B$ 个取值，但是只有 $2B/d$ 个 $y$ 使得方程有解。</p>
<p>表述：所以 $\boldsymbol{t}$向量的 $y$ 值最多只有 $2B/d$ 个。即”short vector” 只有 $2B/d \cdot2B$ 个</p>
<p>表述：每个 $y$ 使方程有解，但其解数是 $d$ 个。<strong>即每一个 “short vector” 对应 $d$ 个 $a$ 值。</strong></p>
<p>表述：同样, $a$ 最多有 $16q/c^2$ 个。</p>
</li>
</ol>
</li>
<li><p>综上， $\mathcal{S}_q$ 中最多有 $16q/c^2$ 个 bad $a$ 。</p>
</li>
<li><p>Therefore, for $(1-16/c^2)\cdot q$   of the a values in $\mathcal{S}_q$ , the lattice $\mathcal{L}_a$  contains no non-zero short vectors and the lemma follows. </p>
<p>【证毕】 </p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol start="0">
<li><p>LCG的数学部分来自Dan教授密码学的公开书:「A Graduate Course in Applied Cryptography」by D. Boneh and V.shoup</p>
</li>
<li><p>A. M. Frieze, R. Kannan, and J. C. Lagarias. Linear congruential generators do not produce random sequences. In FOCS, pages 480{484, 1984}.</p>
</li>
<li><p>P. C. van Oorschot and M. J. Wiener. Parallel collision search with application to hash functions and discrete logarithms. In Proceedings of the 2nd ACM Conference on Computer and Communications Security, pages 210{218, 1994}.</p>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>「Cryptography-Boneh」:Stream Cipher 1</p><p><a href="https://f7ed.com/2020/03/15/stanford-crypto-streamcipher1/">https://f7ed.com/2020/03/15/stanford-crypto-streamcipher1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>f7ed</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-03-15</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-12-28</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/">公开课, </a><a class="link-muted" rel="tag" href="/tags/Cryptography/">Cryptography, </a><a class="link-muted" rel="tag" href="/tags/StreamCipher/">StreamCipher </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/qrcode_wechat.jpg" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/f7ed" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/qrcode_alipay.jpg" alt="Alipay"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/03/15/error/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「机器学习-李宏毅」：Error</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/09/Adagrad-demo/"><span class="level-item">Adagrag-demo</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "af762df974348423ab6e525880e4ba20",
            repo: "f7ed.github.io",
            owner: "f7ed",
            clientID: "ec59f5258ac0ec443907",
            clientSecret: "f092b308c3e1b46327481c3547ee0dd7fc1bda10",
            admin: ["f7ed"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/profile.png" alt="f7ed"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">f7ed</p><p class="is-size-6 is-block">热爱可抵漫长岁月。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">70</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">135</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:f7edliu@outlook.com" target="_blank" rel="noopener">Email me</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#The-One-Time-Pad"><span class="level-left"><span class="level-item">1</span><span class="level-item">The One Time Pad</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Symmetric-Ciphers-difinition"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Symmetric Ciphers: difinition</span></span></a></li><li><a class="level is-mobile" href="#One-Time-Pad-OTP"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">One Time Pad(OTP)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Definition-of-OTP"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Definition of OTP</span></span></a></li><li><a class="level is-mobile" href="#Information-Theoretic-Security"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Information Theoretic Security</span></span></a></li><li><a class="level is-mobile" href="#OTP-has-perfect-secrecy"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">OTP has perfect secrecy</span></span></a></li><li><a class="level is-mobile" href="#key-len-geq-msg-len"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">key-len $\geq$ msg-len</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Pseudorandom-Generators（伪随机数生成器）"><span class="level-left"><span class="level-item">2</span><span class="level-item">Pseudorandom Generators（伪随机数生成器）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Stream-Ciphers-making-OTP-practical"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Stream Ciphers: making OTP practical</span></span></a></li><li><a class="level is-mobile" href="#PRG-must-be-unpredictable"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">PRG must be unpredictable</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Suppose-predictable"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Suppose predictable</span></span></a></li><li><a class="level is-mobile" href="#Predictable-difinition"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">Predictable: difinition</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Weak-PRGs"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Weak PRGs</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Linear-Congruential-Generators"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">Linear Congruential Generators</span></span></a></li><li><a class="level is-mobile" href="#Basic-LCG"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">Basic LCG</span></span></a></li><li><a class="level is-mobile" href="#Variant-Blum-Micali-construction"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">Variant: Blum-Micali construction</span></span></a></li><li><a class="level is-mobile" href="#Cryptanalysis-：elegant-attack"><span class="level-left"><span class="level-item">2.3.4</span><span class="level-item">Cryptanalysis ：elegant attack</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">3</span><span class="level-item">Reference</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 f7ed</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="f7ed&#039;s GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script>
      var sc_project=12961083;
      var sc_invisible=1;
      var sc_security="ad3fb575";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12961083/0/ad3fb575/1/" alt="real time web analytics"></div></noscript><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>