<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「Cryptography-MIT6875」: Lecture 3 - fred&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fred&#039;s blog"><meta name="msapplication-TileImage" content="/img/heart.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fred&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="In this series, I will learn MIT 6.875, Foundations of Cryptography, lectured by Vinod Vaikuntanathan. Any corrections and advice are welcome. ^ - ^    Topics:  The Hybrid Argument. An application:"><meta property="og:type" content="blog"><meta property="og:title" content="「Cryptography-MIT6875」: Lecture 3"><meta property="og:url" content="https://f7ed.com/2022/07/06/mit6875-lec3/"><meta property="og:site_name" content="fred&#039;s blog"><meta property="og:description" content="In this series, I will learn MIT 6.875, Foundations of Cryptography, lectured by Vinod Vaikuntanathan. Any corrections and advice are welcome. ^ - ^    Topics:  The Hybrid Argument. An application:"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://f7ed.com/gallery/covers/mit6875-lec3-banner.png"><meta property="article:published_time" content="2022-07-05T16:00:00.000Z"><meta property="article:modified_time" content="2022-08-12T04:30:33.842Z"><meta property="article:author" content="f7ed"><meta property="article:tag" content="Cryptography"><meta property="article:tag" content="MIT6875"><meta property="article:tag" content="PRG"><meta property="article:tag" content="PRF"><meta property="article:tag" content="Hybrid Argument"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/covers/mit6875-lec3-banner.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://f7ed.com/2022/07/06/mit6875-lec3/"},"headline":"「Cryptography-MIT6875」: Lecture 3","image":["https://f7ed.com/gallery/covers/mit6875-lec3-banner.png"],"datePublished":"2022-07-05T16:00:00.000Z","dateModified":"2022-08-12T04:30:33.842Z","author":{"@type":"Person","name":"f7ed"},"publisher":{"@type":"Organization","name":"fred's blog","logo":{"@type":"ImageObject","url":"https://f7ed.com/img/f1ed_logo.png"}},"description":"In this series, I will learn MIT 6.875, Foundations of Cryptography, lectured by Vinod Vaikuntanathan. Any corrections and advice are welcome. ^ - ^    Topics:  The Hybrid Argument. An application:"}</script><link rel="canonical" href="https://f7ed.com/2022/07/06/mit6875-lec3/"><link rel="icon" href="/img/heart.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-M5KG3CQTSF" async></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-M5KG3CQTSF');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="fred's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/liu">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/mit6875-lec3-banner.png" alt="「Cryptography-MIT6875」: Lecture 3"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-bars"></i>「Cryptography-MIT6875」: Lecture 3</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-07-05T16:00:00.000Z" title="2022-07-05T16:00:00.000Z">2022-07-06</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-08-12T04:30:33.842Z" title="2022-08-12T04:30:33.842Z">2022-08-12</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/Cryptography-MIT6875/">Cryptography-MIT6875</a></span><span class="level-item"><i class="far fa-clock"></i> 33 minutes read (About 4911 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><article class="message message-immersive is-info">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="message-body">
<i class="fas fa-info-circle mr-2"></i>
In this <a href="/categories/Cryptography-MIT6875">series</a>, I will learn MIT 6.875, <strong>Foundations of Cryptography</strong>, lectured by <strong>Vinod Vaikuntanathan</strong>.
<br>Any corrections and advice are welcome. ^ - ^
</div>
</article>

<p>Topics:</p>
<ul>
<li>The Hybrid Argument.</li>
<li>An application: PRG length extension.</li>
<li>The notion of pseudorandom functions: Definition, motivation, discussion and comparison with PRGs.</li>
<li>PRG implies (stateful) secret-key encryption.</li>
<li>PRFs imply (stateless) secret-key encryption.</li>
</ul>
<span id="more"></span>

<h1 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h1><p>In the previous blog, we defined <strong>Computational Indistinguishability</strong> that a new definition of security for secret-key encryption, which can <u>overcome Shannon’s impossibility.</u></p>
<p>Then we brought about  <strong>Pseudorandom Generator</strong> which can encrypt a single message longer than the key. We gave the <u>definition of PRG from the Indistinguishability</u> and <u>proved the secret-key encryption scheme by contradiction.</u> </p>
<p>At the end, we saw a construction of PRG based on subset sum, and answered the question of whether there is a PRG.</p>
<h1 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h1><p>We already know PRG can encrypt a single message longer than the key.</p>
<p>The last blog left the second question to PRG.</p>
<p><strong>Q2: How to encrypt poly. many messages with a fixed key ?</strong></p>
<p>This is the gist of this blog. We’ll introduce two methods.</p>
<ol>
<li><p><strong>PRG length extension.</strong><br>We can achieve <u>stateful</u> encryption of poly. many messages.</p>
<blockquote>
<p><strong>Theorem</strong>:<br> If there is a PRG that stretched by one bit, there is one that stretched by poly. many bits.</p>
</blockquote>
</li>
<li><p>Another new notion: <strong>Pseudorandom Functions</strong> (PRF)<br>We can achieve <u>stateless</u> encryption of poly many messages.</p>
<blockquote>
<p><strong>Theorem</strong>(next blog):<br> If there is a PRG, then there is a PRF.</p>
</blockquote>
</li>
</ol>
<p>More importantly, we’ll introduce <strong>a new proof technique</strong>, <u>Hybrid Arguments.</u></p>
<h1 id="PRG"><a href="#PRG" class="headerlink" title="PRG"></a>PRG</h1><p>In the last blog, we mentioned that there are three equivalent definitions of PRG.</p>
<p><strong>Def 1 [Indistinguishability]</strong></p>
<p>“No polynomial-time algorithm can distinguish between the output of a PRG on a random seed vs. a truly random string.”</p>
<p>= “as good as” a truly random string for all practical purpose.</p>
<p><strong>Def 2 [Next-bit Unpredictability]</strong></p>
<p>“No polynomial-time algorithm can predict the (i+1)th bit of the output of a PRG given the first i bits, better than chance 1/2.”</p>
<p><strong>Def 3 [ Incompressibility]</strong></p>
<p>“No polynomial-time algorithm can compress the output of the PRG into a shorter string”</p>
<h2 id="Def-1-Indistinguishability"><a href="#Def-1-Indistinguishability" class="headerlink" title="Def 1 [Indistinguishability]"></a>Def 1 [Indistinguishability]</h2><p>We elaborated the first definition of Indistinguishability last blog.</p>
 <article class="message is-info"> <div class="message-header">  

<p><strong>Definition 1 [Indistinguishability]:</strong></p>
 </div> <div class="message-body">  

<p>A <strong>deterministic</strong> polynomial-time computable function ${G}:\{0,1\}^n\rightarrow \{0,1\}^m$ is a <strong>indistinguishable</strong> (or, secure against any statistical test) if:</p>
<p>for every p.p.t. algorithm D (called <u>a distinguisher or a statistical test</u>) if there is a negligible function ${\mu}$ such that:</p>
<p>$$<br>|\operatorname{Pr}[D({G(U_n)})=1]-\operatorname{Pr}[D({U_m})=1]|={\mu(n)}<br>$$</p>
<p><u>Notation</u>: $U_n$(resp. $U_m$) denotes the random uniform distribution on $n$-bit (resp. $m$-bit) strings; $m$ is shorthand for $m(n)$.</p>
 </div> </article> 

<p>So $G$ is a PRG if $D$ <strong>cannot</strong> <u>distinguish from the output of the $G$ and a truly random string.</u></p>
<h2 id="Def-2-Next-bit-Unpredictability"><a href="#Def-2-Next-bit-Unpredictability" class="headerlink" title="Def 2 [Next-bit Unpredictability]"></a>Def 2 [Next-bit Unpredictability]</h2><p>Today I will introduce the second definition of <strong>Next-bit Unpredictability.</strong></p>
 <article class="message is-info"> <div class="message-header"> 

<p><strong>Definition 2 [Next-bit Unpredictability]:</strong></p>
 </div> <div class="message-body"> 

<p>A <strong>deterministic</strong> polynomial-time computable function  ${G}:\{0,1\}^n\rightarrow \{0,1\}^m$ is a <strong>next-bit unpredictable</strong> if:</p>
<p>for every p.p.t. algorithm D (called a <u>next-bit predictor</u>) and every $i\in\{0,\dots,m\}$ , if there is a negligible function ${\mu}$ such that:</p>
<p>$$<br>\operatorname{Pr}[y\leftarrow G(U_n):P(y_1y_2\dots y_{i-1})=y_i]=\frac{1}{2}+\mu(n)<br>$$</p>
<p><u>Notation</u>: $y_1,y_2,\dots,y_m$ are the bits of the m-bit string $y$.</p>
 </div> </article> 

<p>So $G$ is a PRG if the probability of $P$ <u>predicting the right $i$th bit</u> of $G$ <u>is substantially half</u> given the first $(i-1)$ bits of $G$.</p>
<h2 id="Ind-NBU"><a href="#Ind-NBU" class="headerlink" title="Ind. = NBU"></a>Ind. = NBU</h2><p>There are two theorems that state the equivalence of Def 1( Indistinguishability) and Def 2(NBU).</p>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>A PRG $G$ is <u>distinguishable</u> <strong>if and only if</strong> it is <u>next-bit unpredictable.</u></p>
<p><font color=blue><u><b>Theorem:</b></u></font> </p>
<p>A PRG $G$ <u>passes all (poly-time) statistical tests</u> if and only if it <u>passes (poly-time) next-bit tests.</u></p>
<hr>
<p>Next-bit Unpredictability(NBU) is <strong>seemingly</strong> a  much weaker requirement. It only says that the next bit predictors, a particular type of distinguishers which takes a prefix of a string and try yo predict the next  bit, cannot succeed.</p>
<p>Yet, surprisingly, <u>Next-bit Unpredictability (NBU) = Indistinguishability (Ind.).</u></p>
<p>In addition, <strong>NBU</strong> is <u>much more easier</u> to use.</p>
<h2 id="Ind-→-NBU"><a href="#Ind-→-NBU" class="headerlink" title="Ind. → NBU"></a>Ind. → NBU</h2><p>The first and foremost, the thing we <strong>want to prove</strong> is that <u>if a PRG $G$ is indistinguishable, then it is next-bit unpredictable</u>, i.e. Ind. → NBU.</p>
<p><font color=blue><u><b>Proof: </b></u></font></p>
<p>The main idea of <strong>contradiction</strong> is that if there exists a p.p.t. predictor $P$, then we can construct a p.p.t distinguisher $D$ from $P$, i.e. NOT NBU → NOT Ind.</p>
<p>So we can </p>
<ul>
<li><p>Suppose for <strong>contradiction</strong> $G$ is <u>NOT Next-bit Unpredictable</u>, i.e. there is a  p.p.t. predictor $P$, a polynomial function $p$ and an $i\in\{1,\dots, m\}$ s.t.</p>
<p>  $$<br>  \operatorname{Pr}[y\leftarrow G(U_n):P(y_1y_2\dots y_{i-1})=y_i]\ge \frac{1}{2}+1/p(n)<br>  $$</p>
<p>  Then, I claim that <u>$P$ essentially gives us a distinguisher $D$.</u></p>
<ul>
<li>The probability of $P$ predicting the right bit is <u>more than half.</u></li>
<li>Consequently, the PRG $G$ is NOT Next-bit Unpredictable.</li>
</ul>
</li>
<li><p><strong>Construct a distinguisher</strong> $D$ from predictor $P$.<br>Consider $D$ which gets an $m$-bit string $y$ and does the following:<br>(If $P$ is p.p.t. so is $D$.)</p>
<ol>
<li>Run $P$ on the $(i-1)$-bit prefix $y_1y_2\dots y_{i-1}$</li>
<li>If $P$ returns the $i$-th bit $y_i’$, then output 1 (=PRG) else output 0 (=Random).</li>
<li> $D(y)=\begin{cases} \text{1(=PRG)},& y_i'=y_i\\ \text{0(=Random)},& \text{otherwise}\end{cases}$ </li>
</ol>
<ul>
<li>The <strong>task of $D$</strong> is to <u>guess which world</u> she is in, the pseudorandom world or the truly random world.</li>
<li>The <strong>task of  $P$</strong> is to <u>predict the next-bit</u> given the first $(i-1)$ bits of $y$.</li>
<li>By the construction of $D$, the probability of $D$ guessing correctly is <strong>equal</strong> to the probability of $P$ predicting the right bit regardless the distribution of $y$, i.e.<ul>
<li>$\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1]=\operatorname{Pr}[y\leftarrow G(U_n):P(y_1y_2\dots y_{i-1})=y_i]$</li>
<li>$\operatorname{Pr}[y\leftarrow U_m:D(y)=1]=\operatorname{Pr}[y\leftarrow U_m:P(y_1y_2\dots y_{i-1})=y_i]$</li>
</ul>
</li>
</ul>
</li>
<li><p>Therefore, we <strong>want to show</strong> that $D$ is able to distinguish the PRG $G$ which means $G$ <u>is NOT Indistinguishable</u>, i.e. there is a polynomial $p’$ s.t. $|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p’(n)$</p>
<ul>
<li>If $y$ <u>is from the pseudorandom world</u>, the probability of $D$ guessing correctly is equal to the probability of $P$ predicting the right bit by the construction of $D$.<ul>
<li>$|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1]|$</li>
<li>= $\operatorname{Pr}[y\leftarrow G(U_n):P(y_1y_2\dots y_{i-1})=y_i]\ge \frac{1}{2}+1/p(n)$ (by assumption)</li>
</ul>
</li>
<li>If $y$ <u>is from the truly world</u>, the probability of $P$ predicting the right bit is 1/2 since $y$ is random.<ul>
<li>$|\operatorname{Pr}[y\leftarrow U_m:D(y)=1]|$</li>
<li>=$\operatorname{Pr}[y\leftarrow U_m:P(y_1y_2\dots y_{i-1})=y_i]=\frac{1}{2}$ ($y$ is random)</li>
</ul>
</li>
</ul>
</li>
<li><p>Hence, the <strong>advantage</strong> of the <u>distinguisher $D$ guessing correctly</u> is<br>$|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p(n)$</p>
</li>
<li><p>QED.</p>
</li>
</ul>
<h2 id="NBU-→-Ind"><a href="#NBU-→-Ind" class="headerlink" title="NBU → Ind."></a>NBU → Ind.</h2><p>Furthermore, we <strong>want to prove</strong> that if a PRG $G$ is next-bit unpredictable, then it is indistinguishable, i.e. <u>NBU → Ind..</u></p>
<p>Equally, suppose for <strong>contradiction</strong> that <u>there is a distinguisher $D$</u>, and a polynomial function $p$ s.t.</p>
<p>$$<br>|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p(n)<br>$$</p>
<p><strong>But how to construct a next-bit predictor $P$ out of the distinguisher $D$ ?</strong></p>
<p>It is imperative that we need a new proof technique, <strong>HYBRID ARGUMENT</strong>.</p>
<p>Using the technique, we can prove it by the following steps:</p>
<ol>
<li>Hybrid Argument</li>
<li>From Distinguishing to Predicting</li>
</ol>
<h1 id="Proof-of-NBU-→-Ind"><a href="#Proof-of-NBU-→-Ind" class="headerlink" title="Proof of NBU → Ind."></a>Proof of NBU → Ind.</h1><h2 id="Step-1-Hybrid-Argument"><a href="#Step-1-Hybrid-Argument" class="headerlink" title="Step 1: Hybrid Argument"></a>Step 1: Hybrid Argument</h2><blockquote>
<p>Hybrid Argument is a proof technique used to show that two distributions are computationally indistinguishable. ——wiki</p>
</blockquote>
<p>The <strong>contradiction</strong> is that there is a distinguisher $D$, and a polynomial function $p$ s.t.<br>$|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p(n)$</p>
<p>We define the <strong>advantage</strong> of $D$ guessing correctly is $\varepsilon:=1/p(n)$.</p>
<h3 id="A-Puzzle"><a href="#A-Puzzle" class="headerlink" title="A Puzzle"></a>A Puzzle</h3><p>Before that, let’s discuss a simple puzzle.</p>
<p><font color=blue><u><b>Lemma:</b></u></font></p>
<p>Let $p_0,p_1,p_2,\dots,p_m$ be real numbers s.t. $\color{blue}{p_m-p_0\ge \varepsilon}$</p>
<p>Then, there is an index $i$ such that $\color{blue}{p_i-p_{i-1}\ge \varepsilon/m}$.</p>
<p><font color=blue><u><b>Proof:</b></u></font> </p>
<ul>
<li>Write it $p_{m}-p_{0}=\left(p_{m}-p_{m-1}\right)+\left(p_{m-1}-p_{m-2}\right)+\cdots+\left(p_{1}-p_{0}\right) \ge \varepsilon$</li>
<li><u>At least one</u> of the $m$ terms has to be <u>at least $\varepsilon/m$</u> (averaging).</li>
</ul>
<h3 id="Hybrid-Distributions"><a href="#Hybrid-Distributions" class="headerlink" title="Hybrid Distributions"></a>Hybrid Distributions</h3><p>We define a sequence of <strong>hybrid distributions</strong> $H_0,H_1,\dots,H_m$, which $H_0:=U_m$ and $H_m:=G(U_n)$. </p>
<img src="https://s1.ax1x.com/2022/07/07/jwsAxI.png" alt="hybrid distributions" style="zoom:25%;" />

<ul>
<li>$H_0$ is the distribution that <u>all bits are random</u> while $H_m$ is the distribution that <u>all bits are pseudorandom.</u></li>
<li>Others are the distributions that some bits are random and others are pseudorandom.</li>
<li>In addition,  there is <u>only one different bit</u> between <strong>the adjacent hybrid distributions</strong> as shown the figure above.</li>
</ul>
<p>According to the <strong>assumption</strong>, $D$ <u>distinguishes the $y$</u> between the pseudorandom world and the truly random world <u>with advantages $\varepsilon$,</u> which means $D$ <u>distinguishes the distribution between $H_m$ and $H_0$ with advantage $\varepsilon$</u>, i.e.</p>
<p>$$<br>\operatorname{Pr}[D(H_m)=1] - \operatorname{Pr}[D(H_0)=1]\ge \varepsilon<br>$$</p>
<img src="https://s1.ax1x.com/2022/07/07/jwrvKx.png" alt="distinguish from Hm and H0" style="zoom:25%;" />

<p>With reference to the <strong>puzzle</strong>, there <u>exists $i$</u> such that $D$ <u>distinguishes the distribution</u> between $H_{i}$ and $H_{i-1}$ with advantage $\ge \varepsilon/m$, i.e. $\exists i$ s.t.</p>
<p>$$<br>\operatorname{Pr}[D(H_i)=1] - \operatorname{Pr}[D(H_{i-1})=1]\ge \varepsilon/m<br>$$</p>
<img src="https://s1.ax1x.com/2022/07/07/jwrqPJ.png" alt="distinguish from Hi and Hi-1" style="zoom:25%;" />

<h3 id="Random-bit-v-s-Pseudorandom-bit"><a href="#Random-bit-v-s-Pseudorandom-bit" class="headerlink" title="Random bit v.s. Pseudorandom bit"></a>Random bit v.s. Pseudorandom bit</h3><p>By the hybrid argument, what <strong>information</strong> can we get from $D$ distinguishing between $H_{i}$ and $H_{i-1}$with advantage $\ge \varepsilon/m$ ?</p>
<p>Let’s summarize it:</p>
<ol>
<li>Define $p_i = \operatorname{Pr}[D(H_i)=1]$.<br>$p_0 = \operatorname{Pr}[D(U_m)=1]$ and $p_m = \operatorname{Pr}[D(G(U_n))=1]$.</li>
<li>By the hybrid argument, we have $p_i-p_{i-1}\ge \varepsilon /m$.</li>
</ol>
<p>The <strong>key intuition</strong> is <u>$D$ output ‘1’ more often given a pseudorandom $i$-th bit than a random $i$-th bit.</u></p>
<p>Therefore, $D$ gives us a “<strong>signal</strong>” as to <u>whether a given bit is the correct $i$-th bit or not.</u></p>
<h3 id="Right-bit-v-s-Wrong-bit"><a href="#Right-bit-v-s-Wrong-bit" class="headerlink" title="Right bit v.s. Wrong bit"></a>Right bit v.s. Wrong bit</h3><p>Let’s dig a bit more.</p>
<p>$H_{i-1}$ is the hybrid distribution the $i$-th bit of which is a <strong>random</strong> bit $u$.</p>
<p>$H_i$ is the hybrid distribution the $i$-th bit of which is the $i$-th <strong>pseudorandom</strong> bit $y_i$ generated by $G$.</p>
<p>We <strong>define a new hybrid distribution $\overline{H_i}$</strong>, the $i$-th bit $\overline{y_i}$ of which is the <strong>opposite bit</strong> $y_i$ in $H_i$.</p>
<img src="https://s1.ax1x.com/2022/07/07/jwrO2R.png" alt="a new hybrid distribution" style="zoom:25%;" />

<p>With reference to $p_i=\operatorname{Pr}[D(H_i)=1]$, we define $\overline{p_i}=\operatorname{Pr}[D(\overline{H_i})=1]$.</p>
<ul>
<li><p>We <strong>know</strong>: $p_i-p_{i-1}\ge \varepsilon/m$.</p>
</li>
<li><p><strong>Claim</strong>: $p_{i-1}=(p_i+\overline{p_i})/2$.<br><font color=blue><u><b>Proof:</b></u></font> </p>
<article class="message message-immersive is-warning"> <div class="message-body"> <i class="fas fa-exclamation-triangle mr-2"></i>The following proof is my <strong>own deduction</strong> since the proof is omitted in the lecture. <br> <strong>Corrections and advice are welcome.</strong> </div> </article>

<ul>
<li>In hybrid distribution $H_{i-1}$, $u$ is <u>a random bit.</u><ul>
<li>So, $\operatorname{Pr}[u=0]=0.5$ and $\operatorname{Pr}[u=1]=0.5$.</li>
<li>$\operatorname{Pr}[D(H_{i-1})=1]$</li>
<li>= $\operatorname{Pr}[D(H_{i-1})=1\wedge u=0]+[D(H_{i-1})=1\wedge u=1]$</li>
<li>= $\operatorname{Pr}[D(H_{i-1})=1\mid u=0]\operatorname{Pr}[u=0]+[D(H_{i-1})=1\mid u=1]\operatorname{Pr}[u=1]$</li>
<li>=$(\operatorname{Pr}[D(H_{i-1})=1\mid u=0]+[D(H_{i-1})=1\mid u=1])/2$</li>
</ul>
</li>
<li>If $u=0$ in $H_{i-1}$, we can use $H_i$ with $y_i=0$ and $\overline{H_{i}}$ with $\overline{y_i}=0$ to express $H_i$.<ul>
<li>$\operatorname{Pr}[D(H_{i-1})=1\mid u=0]$</li>
<li>= $\operatorname{Pr}[D(H_{i-1})=1\wedge y_i=0]+\operatorname{Pr}[D(\overline{H_i})=1\wedge \overline{y_i}=0]$</li>
</ul>
</li>
<li>If $u=1$ in $H_{i-1}$, we can use $H_i$ with $y_i=1$ and $\overline{H_{i}}$ with $\overline{y_i}=1$ to express $H_i$.<ul>
<li>$\operatorname{Pr}[D(H_{i-1})=1\mid u=1]$</li>
<li>= $\operatorname{Pr}[D(H_{i-1})=1\wedge y_i=1]+\operatorname{Pr}[D(\overline{H_i})=1\wedge \overline{y_i}=1]$</li>
</ul>
</li>
<li>Sum it up.<ul>
<li>$\operatorname{Pr}[D(H_{i-1})=1]$</li>
<li>= $(\operatorname{Pr}[D(H_i)=1\wedge y_i=0] +\operatorname{Pr}[D(H_i)=1\wedge y_i=1] \ + \operatorname{Pr}[D(\overline{H_i})=1\wedge \overline{y_i}=0] +\operatorname{Pr}[D(\overline{H_i})=1\wedge \overline{y_i}=1])/2$</li>
<li>= $(\operatorname{Pr}[D(H_i)=1]+\operatorname{Pr}[D(\overline{H_i})=1])/2$</li>
</ul>
</li>
<li>QED.</li>
</ul>
</li>
<li><p>We illustrate the claim as the following figure.<br>$p_{i-1}$ is the <u>midpoint</u> of $p_i$ and $\overline{p_i}$.</p>
</li>
</ul>
<img src="https://s1.ax1x.com/2022/07/07/jwrLG9.png" alt="midpoint" style="zoom:25%;" />

<ul>
<li><strong>Corollary</strong>: $p_i-\overline{p_i}\ge 2\varepsilon/m$ (w.r.t. the claim)</li>
</ul>
<p>What can we learn from $p_i-\overline{p_i}\ge 2\varepsilon/m$ ?</p>
<p>The <strong>takeaway</strong> is that $D$ <u>says ‘1’more often when fed with the ‘right bit’ than the ‘wrong bit’.</u></p>
<h2 id="Step-2-From-Distinguishing-to-Predicting"><a href="#Step-2-From-Distinguishing-to-Predicting" class="headerlink" title="Step 2: From Distinguishing to Predicting"></a>Step 2: From Distinguishing to Predicting</h2><p> By the hybrid argument, we get the takeaway:  $p_i-\overline{p_i}\ge 2\varepsilon/m$. ( $p_i=\operatorname{Pr}[D(H_i)=1]$ )</p>
<p>The distinguisher $D$ outputs ‘1’ more often when fed with the ‘right bit’ than the ‘wrong bit’.</p>
<h3 id="The-Predictor-P"><a href="#The-Predictor-P" class="headerlink" title="The Predictor $P$"></a>The Predictor $P$</h3><p>The predictor is given the first $i-1$ pseudorandom bits (call it $y_1y_2\dots y_{i-1}$) and needs to guess the $i$-th bit.</p>
<p>The Predictor $P$ works as follows:</p>

$$
P(y_1y_2\dots y_{i-1})=\begin{cases} b,& \text{if }D(y_1y_2\dots y_{i-1}|b| u_{i+1}\dots u_m)=1\\ \overline{b},& \text{otherwise}\end{cases},b\leftarrow\{0,1\}
$$



<ol>
<li>Pick a <u>random</u> bit $b$</li>
<li>Feed $D$ with input $y_1y_2\dots y_{i-1}|b| u_{i+1}\dots u_m$ ($u$’s are random).</li>
<li>If D says ‘1’, output $b$ as the prediction for $y_i$ and if $D$ says ‘0’, output $\overline{b}$ as the prediction for $y_i$.</li>
</ol>
<h3 id="Analysis-of-Predictor-P"><a href="#Analysis-of-Predictor-P" class="headerlink" title="Analysis of Predictor $P$"></a>Analysis of Predictor $P$</h3><ul>
<li>The probability of $P$ predicting the right bit<br>$\operatorname{Pr}[x\leftarrow {0,1}^n;y=G(x):P(y_1y_2\dots\ y_{i-1})=y_i]$</li>
<li>consists of <strong>two cases</strong> where $D$ outputs 1 and $D$ outputs 0.<ul>
<li>= $\operatorname{Pr}[D(y_1y_2\dots y_{i-1}b\dots)=1 \wedge b=y_i]+\operatorname{Pr}[D(y_1y_2\dots y_{i-1}b\dots)=0\wedge b\ne y_i]$ ($y_i=b \text{ or } y_i=\overline{b}$)</li>
<li>= $\operatorname{Pr}[D(y_1y_2\dots y_{i-1}b\dots)=1 \mid b=y_i]\operatorname{Pr}[b=y_i] \ +\operatorname{Pr}[D(y_1y_2\dots y_{i-1}b\dots)=0\mid b\ne y_i]\operatorname{Pr}[b\ne y_i]$</li>
<li>= $\frac{1}{2}(\operatorname{Pr}[D(y_1y_2\dots y_{i-1}y_i\dots)=1]+\operatorname{Pr}[D(y_1y_2\dots y_{i-1}\overline{y_i}\dots)=0)$ (since b is random)</li>
<li>= $\frac{1}{2}(\operatorname{Pr}[D(y_1y_2\dots y_{i-1}y_i\dots)=1]+1-\operatorname{Pr}[D(y_1y_2\dots y_{i-1}\overline{y_i}\dots)=1)$</li>
<li>= $\frac{1}{2}(1+\varepsilon/m)\ge \frac{1}{2} + 1/p(n)$  (since $m$ is also a polynomial in $n$)</li>
<li>QED.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>SUMMARIZE:</strong> </p>
<p>We <strong>want to prove</strong> that if the $G$ is next-bit predictable, then $G$ is indistinguishable.</p>
<ol>
<li><strong>Hybrid Argument</strong><ol>
<li>Suppose the <strong>contradiction</strong> that there is a $D$ <u>distinguishing</u> from the pseudorandom world and the truly random world with advantage $\varepsilon$.<br>$\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]\ge \varepsilon$</li>
<li>By defining a sequence of <u>hybrid distribution</u>s, we know that $D$ outputs ‘1’ more often when fed with a pseudorandom bit than fed a random bit.<br>$p_i-p_{i-1}\ge \varepsilon/m \qquad(p_i=\operatorname{Pr}[D(H_i)=1])$</li>
<li>Dig it more. We get the <u>takeaway</u> that $D$ <u>says ‘1’ more often when fed a right bit than a wrong bit.</u><br>$p_i-\overline{p_i}\ge 2\varepsilon/m \qquad(\overline{p_i}=\operatorname{Pr}[D(\overline{H_i})=1])$</li>
</ol>
</li>
<li><strong>From distinguishing to predicting</strong><ol>
<li><strong>Construct</strong> a <u>predictor</u> $P$ from the distinguisher $D$  
    
      $P(y_1y_2\dots y_{i-1})=\begin{cases} b,& \text{if }D(y_1y_2\dots y_{i-1}|b| u_{i+1}\dots u_m)=1\\ \overline{b},& \text{otherwise}\end{cases},b\leftarrow\{0,1\}$ 
      </li>
<li>Analysis the probability of $P$ predicting the right bit.<br> By the hybrid argument, we can deduce 
    
       $\operatorname{Pr}[x\leftarrow \{0,1\}^n;y=G(x):P(y_1y_2\dots\ y_{i-1})=y_i]\ge1/2+1/p(n)$.
        </li>
<li>So the probability of $P$ <u>predicting the right bit is more than half.</u></li>
</ol>
</li>
</ol>
<h1 id="Proof-of-PBU-Ind"><a href="#Proof-of-PBU-Ind" class="headerlink" title="Proof of PBU = Ind."></a>Proof of PBU = Ind.</h1><p>We have proven that Next-bit Unpredictability = Indistinguishability.</p>
<p>Actually, Previous-bit Unpredictability(PBU) is equal to Indistinguishability, i.e. <u>PUB = Ind..</u></p>
<article class="message message-immersive is-warning"> <div class="message-body"> <i class="fas fa-exclamation-triangle mr-2"></i>I write it down just to exercise. <br>The proof is similar with the proof of NBU=IND, so <strong>you can skip reading</strong> it.</div> </article>

<p><font color=blue><u><b>Proof:</b></u></font></p>
<ul>
<li><p>Prove PUB → Ind.</p>
<ol>
<li>Suppose for the <u>contradiction</u> that there is a p.p.t. predictor $P$, a polynomial function $p$ and an  $i\in\{1,2,\dots,m\}$ s.t.<br>$\operatorname{Pr}[y\leftarrow G(U_n):P(y_{i+1}y_{i+2}\dots y_m)=y_i]\ge 1/2+p(n)$</li>
<li>Construct a <u>distinguisher</u> $D$ from $P$  
        $D(y)=\begin{cases} \text{1(=PRG)}&, P(y_{i+1}y_{i+2}\dots y_m)=y_i\\ \text{0(=Random)}&, \text{otherwise}\end{cases}$ 
        </li>
<li><u>Analysis</u> the probability of $D$ distinguishing $y$.<ol>
<li>If $y$ is from pseudorandom world<br>$\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] \ = \operatorname{Pr}[y\leftarrow G(U_n):P(y_{i+1}y_{i+2}\dots y_m)=y_i]\ge 1/2+p(n)$</li>
<li>If $y$ is from the truly random world<br>$|\operatorname{Pr}[y\leftarrow U_m:D(y)=1]| \ =\operatorname{Pr}[y\leftarrow U_m:P(y_{i+1}y_{i+2}\dots y_m)=y_i]= 1/2$</li>
<li>The advantage of $D$ distinguishing $y$ is non-negligible.<br>$|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p(n)$</li>
</ol>
</li>
<li>QED.</li>
</ol>
</li>
<li><p>Prove Ind. → PUB</p>
<ol>
<li><p>Suppose for the contradiction that there is a p.p.t distinguisher $D$, a polynomial function $p$ s.t.<br>$|\operatorname{Pr}[y\leftarrow G(U_n):D(y)=1] - \operatorname{Pr}[y\leftarrow U_m:D(y)=1]|\ge 1/p(n):=\varepsilon$ </p>
</li>
<li><p><u>Hybrid Argument</u></p>
<ol>
<li><p>Define a sequence of hybrid distributions $H_0:=U_m,H_1,\dots,H_m=G(U_n)$<br>Define $p_i=\operatorname{Pr}[D(H_i)=1]$</p>
 <img src="https://s1.ax1x.com/2022/07/07/jwrXx1.png" alt="Hybrid Distributions" style="zoom:25%;" />
</li>
<li><p>We <u>know</u> $p_m-p_0\ge \varepsilon$ from the contradiction.</p>
</li>
<li><p>Define $\overline{p_i}=\operatorname{Pr}[D(\overline{H_i})=1]$ where the $i$-th bit in $\overline{H_i}$ is the opposite bit of the $i$-th bit in $H_i$.</p>
</li>
<li><p>We <u>claim</u> $p_{i-1}=(p_i+\overline{p_i})/2$ . (The proof is same with the above)</p>
 <img src="https://s1.ax1x.com/2022/07/07/jwrLG9.png" alt="midpoint" style="zoom:25%;" />
</li>
<li><p>Get the <u>corollary</u> $p_i-\overline{p_i}\ge 2\varepsilon/m$.<br>Takeaway: $D$ output ‘1’ more often when fed with a right bit than a wrong bit.</p>
</li>
</ol>
</li>
<li><p><u>From distinguishing to predicting</u></p>
<ol>
<li>Construct a <u>predictor</u> $P$ from the $D$  
        
             $P(y_{i+1}y_{i+2}\dots y_m)\begin{cases} b,& \text{if }D(u_1u_2\dots u_{i-1}|b| y_{i+1}y_{i+2}\dots y_m)=1\\ \overline{b},& \text{otherwise}\end{cases}\\b\leftarrow\{0,1\},u\text{ is random.}$ 
            </li>
<li><u>Analyze</u> the probability of $P$ predicting.<ol>
<li>$\operatorname{Pr}[y\leftarrow G(U_n):P(y_{i+1}y_{i+2}\dots y_m)=y_i]$</li>
<li>= $\operatorname{Pr}[D(\dots b y_{i+1}y_{i+2}\dots y_m)=1 \wedge b=y_i]+\operatorname{Pr}[D(\dots b y_{i+1}y_{i+2}\dots y_m)=0\wedge b\ne y_i]$($y_i=b \text{ or } y_i=\overline{b}$) </li>
<li>=$\frac{1}{2}(\operatorname{Pr}[D(\dots y_i y_{i+1}y_{i+2}\dots y_m)=1]+\operatorname{Pr}[D(\dots \overline{y_i} y_{i+1}y_{i+2}\dots y_m)=0)$ (since b is random)</li>
<li>=$\frac{1}{2}(\operatorname{Pr}[D(\dots y_i y_{i+1}y_{i+2}\dots y_m)=1]+1-\operatorname{Pr}[D(\dots \overline{y_i} y_{i+1}y_{i+2}\dots y_m)=1)$</li>
<li>=$\frac{1}{2}(1+\varepsilon/m)\ge \frac{1}{2} + 1/p(n)$ </li>
<li>QED.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="PRG-Length-Extension"><a href="#PRG-Length-Extension" class="headerlink" title="PRG Length Extension"></a>PRG Length Extension</h1><p>Let  $G:\{0,1\}^n\rightarrow \{0,1\}^{n+1}$ be a pseudorandom generator.</p>
<p>The goal is to used $G$ to generate <strong>poly. many</strong> pseudorandom bits.</p>
<p>The construction $G’$  consists of poly. many calls of $G$. </p>
<ul>
<li>The input of $G’$ is $s_0$ ($n$-bit).</li>
<li>The output of $G$ is <u>parsed</u> by $b_i||s_i$, which $b_i$ is 1-bit and $s_i$ is $n$-bit.</li>
<li>The output of $G’$ are poly. many pseudorandom bit.</li>
</ul>
<img src="https://s1.ax1x.com/2022/07/07/jwrzqK.png" alt="Construction of G'" style="zoom:30%;" />

<p>It’s also called a stream cipher by the practitioners.</p>
<h2 id="Security-Analysis"><a href="#Security-Analysis" class="headerlink" title="Security Analysis"></a>Security Analysis</h2><p><font color=blue><u><b>Theorem:</b></u></font></p>
<p>If there is a PRG that stretched by one bit, there is one that stretched by poly. many bits.</p>
<article class="message message-immersive is-warning"> <div class="message-body"> <i class="fas fa-exclamation-triangle mr-2"></i>The following proof is my <strong>own deduction</strong> since the proof is omitted in the lecture. <br> <strong>Corrections and advice are welcome.</strong> </div> </article>

$G:\{0,1\}^n\rightarrow \{0,1\}^{n+1}$ is a PRG that stretched by one bit.

<p>Define $G’(s_0)=b_1b_2\dots b_L$ with the above construction, which is a PRG that stretched by poly. many bits.<br>$s_0$ is $n$-bit random string and $L$ is a polynomial in $n$.</p>
<p>The thing <strong>we want to prove</strong> is that if  $G:\{0,1\}^n\rightarrow \{0,1\}^{n+1}$ is a secure PRG, then $G':\{0,1\}^n\rightarrow \{0,1\}^{n+L}$ is a secure PRG.</p>
<p>There are many definitions of PRG, but it’s easy to work with <strong>Previous-bit Unpredictability</strong> here.</p>
<p><font color=blue><u><b>Proof:</b></u></font> </p>
<ul>
<li>Suppose for the <strong>contradiction</strong> that there is a p.p.t. <u>predictor</u> $P$, who can predict the previous-bit, and a polynomial function $p$ and an $i\in\{1,2,\dots,L\}$ s.t.<br>$\operatorname{Pr}[b\leftarrow G’(U_n):P(b_{i+1}b_{i+2}\dots b_L)=b_i] \ge 1/p(n):=\varepsilon$</li>
<li>Then the <u>predictor</u> $P$ essentially <u>gives us an adversary $A$ against $G$.</u><ul>
<li>The <strong>task</strong> of $A$ is to predict $b_i$ given $s_i$ that $b_i$ is the first bit of $G(s_{i-1})=b_i||s_i$.</li>
<li>The <strong>construction</strong> of $A$<ol>
<li>Run $G’$ <u>on the seed $s_i$.</u><br>We can get $b_{i+1},b_{i+2},\dots,b_L$ from the output of $G’(s_i)$.</li>
<li>Feed $P$ with $b_{i+1},b_{i+2},\dots,b_L$.</li>
<li>$A$ returns the output of $P$.</li>
</ol>
</li>
<li><strong>Analysis</strong> of the adversary $A$ predicting the previous bit.<ul>
<li>$\operatorname{Pr}[b_i||s_i\leftarrow G(U_n):A(s_i)=b_i]$</li>
<li>= $\operatorname{Pr}[(b_{i+1},b_{i+2},\dots,b_L)\leftarrow G’(s_i):P(b_{i+1},b_{i+2},\dots,b_L)=b_i]$</li>
<li>= $\operatorname{Pr}[b\leftarrow G’(U_n):P(b_{i+1},b_{i+2},\dots,b_L)=b_i]\ge 1/p(n)$</li>
<li>QED.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Stateful-Secret-key-Encryption"><a href="#Stateful-Secret-key-Encryption" class="headerlink" title="Stateful Secret-key Encryption"></a>Stateful Secret-key Encryption</h2><p>From the <u>PRG length extension</u>, we can <u>encrypt poly. many messages with a fixed key.</u></p>
<p>The <strong>procedure</strong> is as follows.</p>
<ol>
<li><p>Alice and Bob have an agreed key $s_0$ as the initial state of $G’$</p>
 <img src="https://s1.ax1x.com/2022/07/07/jwrxr6.png" alt="Initial state s0" style="zoom:33%;" /> 
</li>
<li><p>Alice wants to encrypt a 1-bit $m$.<br>Then Alice and Bob uses $G’(s_0)$ to generate 1 bit $b_1$  as the one-time pad key, and their states convert to $s_1$.</p>
 <img src="https://s1.ax1x.com/2022/07/07/jwspVO.png" alt="State s1" style="zoom:25%;" />
</li>
<li><p>Alice wants to encrypt a 3-bit $m’$.<br>Then Alice and Bob uses $G’(s_1)$ to generate 3 bits $b_2b_3b_4$ as the one-time pad key, and their states convert to $s_4$.</p>
 <img src="https://s1.ax1x.com/2022/07/07/jws9aD.png" alt="State s4" style="zoom:25%;" />
</li>
<li><p>Now Bob wants to encrypt a 1-bit $m’’$.<br>Then Alice and Bob uses $G’(s_4)$ to generate 1 bit $b_5$ as the one-time pad key, and their states convert to $s_5$.</p>
 <img src="https://s1.ax1x.com/2022/07/07/jwsCIe.png" alt="State s5" style="zoom:25%;" />


</li>
</ol>
<hr>
<p>It’s achievable that Alice and Bob can keep encrypting as many bits as they wish.</p>
<p>However, Alice and Bob <u>have to keep their states in perfect synchrony.</u> </p>
<p>They cannot transmit simultaneously. Otherwise, correctness goes down the drain, so does security.</p>
<h1 id="PRF"><a href="#PRF" class="headerlink" title="PRF"></a>PRF</h1><p>It’s <strong>stateful</strong> encryption using PRG length extension.</p>
<p>How to be stateless ?</p>
<p>There is <strong>an idea</strong> that Alice and Bob can <u>generate (poly.) many and many  bits</u>, such as $n^{100}$ bits.</p>
<p>If Alice want to encrypt 1-bit $m$, she can <u>use a random key $b_x$ indexed by the random number</u> $x$ she picks up and send $(x,m\oplus b_x$) to Bob.</p>
<img src="https://s1.ax1x.com/2022/07/07/jwsFGd.png" alt="stateless secret-key encryption" style="zoom:25%;" />

<p>Yet, it dose <strong>not</strong> work.</p>
<p>Because there is a <strong>collision</strong> of Alice <u>using the same one-time key</u> with <u>non-negligible probability.</u><br>$\operatorname{Pr}[\text{Alice’s first two indices collide}]\ge 1/n^{100}$</p>
<p>To prevent the collision, there is <strong>another idea</strong> that Alice and Bob can <u>generate $2^n$ bits</u> and the probability of collision is negligible.<br>$\operatorname{Pr}[\exists \text{ collision in }t=p(n)\text{ indices}]\le t^2/2^n=neg(n)$</p>
<p><strong>But</strong> it brings about another problem that <u>Alice and Bob are not poly-time.</u></p>
<hr>
<p>Although it dose not work, there is some inspiration.</p>
<p>The <strong>goal</strong> is <u>never compute the exponentially long string explicitly</u> since it’s not poly-time.</p>
<p>Instead, we want a <strong>function</strong> $f_k(x)=b_x$, that $b_x$ is <u>the $x$-th bit in the implicitly defined</u> (pseudorandom) string. It is <u>computable in polynomial time</u> $p(|x|)=p(n)$ that $|x|$ is the length of $x$.</p>
<p>And $f_k(x_1),f_k(x_2)\dots$ <u>are computationally indistinguishable</u> from random bits for random $x_1,x_2,\dots$</p>
<img src="https://s1.ax1x.com/2022/07/07/jwsiPH.png" alt="compute f(x) in poly time" style="zoom:33%;" />

<p>Hence, there is <u>no need to store the state</u> after each encryption since you can get the encryption key directly by computing the function.</p>
<p>Consequently, it is the <strong>stateless</strong> encryption of poly. many messages.</p>
<p>The functions are called <strong>Pseudorandom Functions.</strong></p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Consider these two collections of functions.</p>
<p><u><b>Collection of the Pseudorandom Functions:</b></u> </p>
<p>Consider the <strong>collection</strong> of pseudorandom functions $\mathcal{F}_l=\{f_k:\{0,1\}^l\rightarrow\{0,1\}^m\}_{k\in\{0,1\}^n}$, each of which maps $l$ bits to $m$ bits.</p>
<ul>
<li><u>indexed by a key $k$.</u></li>
<li>$n$ :  key length, $l$: input length, $m$: output length.</li>
<li>Independent parameters, all poly(sec-param)=poly(n).</li>
<li>#functions in $\mathcal{F}_l\le 2^n$ (<u>single exponential</u> in $n$)</li>
</ul>
<p>Every (pseudorandom) function is indexed by the key $k$, so <u>if the $k$ is fixed, the function $f_k$ is fixed.</u></p>
<p>So the number of functions in the pseudorandom world <u>is up to the number of the keys</u>, that is $2^n$.</p>
<p><u><b>Collection of ALL Functions:</b></u> </p>
<p>Consider the <strong>collection</strong> of ALL functions  $ALL_l=\{f:\{\ 0,1\}^l\rightarrow \{0,1\}^m\}$, each of which is maps $l$ bits to $m$ bits.</p>
<ul>
<li>#functions in $ALL_l\le 2^{m2^l}$ (doubly exponential in $l$)</li>
</ul>
<p>For a fixed $m$-bit string in the output space, there are at most $2^l$ possible inputs with different functions. So the number of the functions in the random world is at most $(2^m)^{2^l}=2^{m2^l}$, which is <u>doubly exponential.</u></p>
<hr>
<p>The <u>#functions</u> in the pseudorandom world <u>is much less than</u> that in the random world.</p>
<p>But the pseudorandom functions should be “<strong>indistinguishable</strong>” from random.</p>
<p>There are two worlds, the pseudorandom world and the random world.</p>
<img src="https://s1.ax1x.com/2022/07/07/jwsVMt.png" alt="PRF is indistinguishable from random" style="zoom:25%;" />

<ul>
<li><u>The pseudorandom world</u><ol>
<li>Sample a function $f$ from $\mathcal{F}_l$.<br>The function $f$ is <u>picked one and stays fixed for all</u>. The oracle is instantiated once the $f$ is picked.</li>
<li>The oracle responses $f(x)$ for each query $x$.<br>You can think there is a truth table of $f$ in the oracle.<br>It responses the same $f(x)$ for the same query $x$ since the function $f$ is fixed.</li>
</ol>
</li>
<li><u>The random world</u><ol>
<li>sample a function $f$ from $ALL_l$.<br>Likewise, the function $f$ is <u>picked one and stays fixed for all.</u> The oracle is instantiated once the $f$ is picked.</li>
<li>The oracle responses $f(x)$ for each query $x$.<br>Likewise, it responses the same $f(x)$ for the same query $x$ since the function $f$ is fixed.</li>
</ol>
</li>
<li>The Distinguisher $D$ <u>has the power of querying the oracle many poly. times</u> and <u>try to guess which world</u> she is in, the pseudorandom world or the random world.</li>
</ul>
 <article class="message is-info"> <div class="message-header"> 

<p><strong>Definition:</strong></p>
 </div> <div class="message-body"> 

<p>For all p.p.t. $D$, there is a negligible function $\mu$ s.t.</p>
<p>$$<br>|\operatorname{Pr}[f\leftarrow \mathcal{F}_l:D^f(1^n)=1]-\operatorname{Pr}[f\leftarrow ALL_l:D^f(1^n)=1]|\le \mu(n)<br>$$</p>
<p><u>Notation</u>: You can consider the subscript $f$ as an interactive C program, which fed with an input and outputs the result. The distinguisher $D$ actually gets nothing as input except the secure parameter.</p>
 </div> </article> 

<h2 id="Stateless-Secret-key-Encryption"><a href="#Stateless-Secret-key-Encryption" class="headerlink" title="Stateless Secret-key Encryption"></a>Stateless Secret-key Encryption</h2><p>We can define <u>the stateless secret-key encryption scheme</u> from PRF.</p>
<ul>
<li>$Gen(1^n)$: Generate a random $n$-bit key $k$ that defines $f_k:\{0,1\}^l\rightarrow \{0,1\}^m$ <br>The <u>domain size</u> of $f_k$, $2^l$, had better be <u>super-polynomially</u> large in $n$. </li>
<li>$Enc(k,m)$: Pick a random $x$ and let the ciphertext $c$ be the pair $(x,y=f_k(x)\oplus m)$.</li>
<li>$Dec(k,c=(x,y))$: Output $f_k(x)\oplus y$</li>
</ul>
<p><font color=blue><u><b><i>Correctness</i></b></u></font> </p>
<p>$Dec(k,c)=f_k(x)\oplus y=f_k(x)\oplus f_k(x)\oplus m=m$.</p>
<hr>
<p>Alice and Bob agree with the key $k$, <u>which defines the pseudorandom function $f_k$.</u></p>
<p>When decrypting, Bob <u>computes the one-time key directly</u> through $f_k(x)$.</p>
<p>They don’t need to store $f_k$( or, the giant truth table), <u>the only thing they need to store is the key $k$.</u></p>
<p>In the next blog, we’ll introduce the <strong>theorem</strong> that <u>if there is a PRG, then there is a PRF.</u></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>「Cryptography-MIT6875」: Lecture 3</p><p><a href="https://f7ed.com/2022/07/06/mit6875-lec3/">https://f7ed.com/2022/07/06/mit6875-lec3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>f7ed</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-07-06</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-08-12</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Cryptography/">Cryptography, </a><a class="link-muted" rel="tag" href="/tags/MIT6875/">MIT6875, </a><a class="link-muted" rel="tag" href="/tags/PRG/">PRG, </a><a class="link-muted" rel="tag" href="/tags/PRF/">PRF, </a><a class="link-muted" rel="tag" href="/tags/Hybrid-Argument/">Hybrid Argument </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/qrcode_wechat.jpg" alt="Wechat"></span></a><a class="button donate" href="https://www.buymeacoffee.com/f7ed" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/qrcode_alipay.jpg" alt="Alipay"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/07/08/mit6875-lec4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「Cryptography-MIT6875」: Lecture 4</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/07/02/mit6875-lec2/"><span class="level-item">「Cryptography-MIT6875」: Lecture 2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "9e55c94bcab5a6f9f827a2c1274a4c24",
            repo: "f7ed.github.io",
            owner: "f7ed",
            clientID: "ec59f5258ac0ec443907",
            clientSecret: "f092b308c3e1b46327481c3547ee0dd7fc1bda10",
            admin: ["f7ed"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/profile.png" alt="f7ed"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">f7ed</p><p class="is-size-6 is-block">热爱可抵漫长岁月。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">139</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="mailto:f7edliu@outlook.com" target="_blank" rel="noopener">Email me</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Recap"><span class="level-left"><span class="level-item">1</span><span class="level-item">Recap</span></span></a></li><li><a class="level is-mobile" href="#Agenda"><span class="level-left"><span class="level-item">2</span><span class="level-item">Agenda</span></span></a></li><li><a class="level is-mobile" href="#PRG"><span class="level-left"><span class="level-item">3</span><span class="level-item">PRG</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Def-1-Indistinguishability"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Def 1 [Indistinguishability]</span></span></a></li><li><a class="level is-mobile" href="#Def-2-Next-bit-Unpredictability"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Def 2 [Next-bit Unpredictability]</span></span></a></li><li><a class="level is-mobile" href="#Ind-NBU"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Ind. = NBU</span></span></a></li><li><a class="level is-mobile" href="#Ind-→-NBU"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Ind. → NBU</span></span></a></li><li><a class="level is-mobile" href="#NBU-→-Ind"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">NBU → Ind.</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Proof-of-NBU-→-Ind"><span class="level-left"><span class="level-item">4</span><span class="level-item">Proof of NBU → Ind.</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Step-1-Hybrid-Argument"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Step 1: Hybrid Argument</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#A-Puzzle"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">A Puzzle</span></span></a></li><li><a class="level is-mobile" href="#Hybrid-Distributions"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">Hybrid Distributions</span></span></a></li><li><a class="level is-mobile" href="#Random-bit-v-s-Pseudorandom-bit"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">Random bit v.s. Pseudorandom bit</span></span></a></li><li><a class="level is-mobile" href="#Right-bit-v-s-Wrong-bit"><span class="level-left"><span class="level-item">4.1.4</span><span class="level-item">Right bit v.s. Wrong bit</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Step-2-From-Distinguishing-to-Predicting"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Step 2: From Distinguishing to Predicting</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-Predictor-P"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">The Predictor $P$</span></span></a></li><li><a class="level is-mobile" href="#Analysis-of-Predictor-P"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">Analysis of Predictor $P$</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Proof-of-PBU-Ind"><span class="level-left"><span class="level-item">5</span><span class="level-item">Proof of PBU = Ind.</span></span></a></li><li><a class="level is-mobile" href="#PRG-Length-Extension"><span class="level-left"><span class="level-item">6</span><span class="level-item">PRG Length Extension</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Security-Analysis"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Security Analysis</span></span></a></li><li><a class="level is-mobile" href="#Stateful-Secret-key-Encryption"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Stateful Secret-key Encryption</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PRF"><span class="level-left"><span class="level-item">7</span><span class="level-item">PRF</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Definition"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Definition</span></span></a></li><li><a class="level is-mobile" href="#Stateless-Secret-key-Encryption"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Stateless Secret-key Encryption</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f1ed_logo.png" alt="fred&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 f7ed</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="f7ed&#039;s GitHub" href="https://github.com/f7ed"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script>
      var sc_project=12961083;
      var sc_invisible=1;
      var sc_security="ad3fb575";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12961083/0/ad3fb575/1/" alt="real time web analytics"></div></noscript><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>